{
    "integer_overflow_1.sol": [
        [
            "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/integer_overflow/integer_overflow_1.sol\n * @author: -\n * @vulnerable_at_lines: 14\n */\n\n pragma solidity ^0.8.0;\n\n contract Overflow {\n     uint private sellerBalance=0;\n\n     function add(uint value) public returns (bool){\nrequire(value + sellerBalance >= sellerBalance);\n         sellerBalance += value; // possible overflow\n\n         // possible auditor assert\n         // assert(sellerBalance >= value);\n     }\n\n  // function safe_add(uint value) returns (bool){\n  //   require(value + sellerBalance >= sellerBalance);\n  // sellerBalance += value;\n  // } \n }",
            13,
            "require(value + sellerBalance >= sellerBalance);"
        ]
    ],
    "integer_overflow_mapping_sym_1.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mapping_sym_1.sol\n * @author: -\n * @vulnerable_at_lines: 16\n */\n\n//Single transaction overflow\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowMappingSym1 {\n    mapping(uint256 => uint256) map;\n\n    function init(uint256 k, uint256 v) public {\nrequire(k > 0);\n        map[k] = v;\n    }\n\n    function run(uint256 k, uint256 v) public {\nrequire(k > 0);\n        map[k] -= v;\n    }\n}",
            15,
            "require(k > 0);\n        map[k] = v;\n    }\n\n    function run(uint256 k, uint256 v) public {\nrequire(k > 0);"
        ]
    ],
    "integer_overflow_benign_1.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_benign_1.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow never escapes function\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowBenign1 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(input < 100);\n        // <yes> <report> ARITHMETIC\n        count = count + input;\n        uint res = count - input;\n    }\n}\n\ncontract IntegerOverflowBenign2 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(input < 100);\n        // <yes> <report> ARITHMETIC\n        count = count + input;\n        uint res = count - input;\n    }\n}\n\ncontract IntegerOverflowBenign3 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(input < 100);\n        // <yes> <report> ARITHMETIC\n        count = count + input;\n        uint res = count - input;\n    }\n}\n\ncontract IntegerOverflowBenign4 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(input < 100);\n        // <yes> <report> ARITHME);\n        uint res = count - input;\n    }\n}",
            16,
            "require(input < 100);\n        // <yes> <report> ARITHMETIC\n        count = count + input;\n        uint res = count - input;\n    }\n}\n\ncontract IntegerOverflowBenign2 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(input < 100);\n        // <yes> <report> ARITHMETIC\n        count = count + input;\n        uint res = count - input;\n    }\n}\n\ncontract IntegerOverflowBenign3 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(input < 100);\n        // <yes> <report> ARITHMETIC\n        count = count + input;\n        uint res = count - input;\n    }\n}\n\ncontract IntegerOverflowBenign4 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(input < 100);\n        // <yes> <report> ARITHME);"
        ]
    ],
    "integer_overflow_mul.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mul.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowMul {\n    uint public count = 2;\n\n    function run(uint256 input) public {\nrequire(count < 10);\n        // <yes> <report> ARITHMETIC\n        count = count * input;\n    }\n}\n\n//Multiple transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowMulMultiple {\n    uint public count = 2;\n\n    function run(uint256 input) public {\nrequire(count < 10);\n        // <yes> <report> ARITHMETIC\n        count = count * input;\n    }\n}\n\n//Single transaction underflow\n//Post-transaction effect: underflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerUnderflowMul {\n    uint public count = 2;\n\n    function run(uint256 input) public {\nrequire(count < 10);\n        // <yes> <report> ARITHMETIC\n        count = count * input;\n    }\n}\n\n//Multiple transaction underflow\n//Post);\n        count *= input;\n    }\n}",
            16,
            "require(count < 10);\n        // <yes> <report> ARITHMETIC\n        count = count * input;\n    }\n}\n\n//Multiple transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowMulMultiple {\n    uint public count = 2;\n\n    function run(uint256 input) public {\nrequire(count < 10);\n        // <yes> <report> ARITHMETIC\n        count = count * input;\n    }\n}\n\n//Single transaction underflow\n//Post-transaction effect: underflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerUnderflowMul {\n    uint public count = 2;\n\n    function run(uint256 input) public {\nrequire(count < 10);\n        // <yes> <report> ARITHMETIC\n        count = count * input;\n    }\n}\n\n//Multiple transaction underflow\n//Post);"
        ]
    ],
    "tokensalechallenge.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101 // https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n * @vulnerable_at_lines: 23,25,33\n */\n\npragma solidity ^0.8.0;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    constructor(address _player) payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\nrequire(balanceOf[msg.sender] + numTokens <= 10000);\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n\n        payable(msg.sender).transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}",
            22,
            "require(balanceOf[msg.sender] + numTokens <= 10000);"
        ],
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101 // https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n * @vulnerable_at_lines: 23,25,33\n */\n\npragma solidity ^0.8.0;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    constructor(address _player) payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\nrequire(balanceOf[msg.sender] + numTokens <= 1000);\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n\n        payable(msg.sender).transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}",
            24,
            "require(balanceOf[msg.sender] + numTokens <= 1000);"
        ],
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101 // https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n * @vulnerable_at_lines: 23,25,33\n */\n\npragma solidity ^0.8.0;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    constructor(address _player) payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\nrequire(msg.value == numTokens * PRICE_PER_TOKEN);\n        payable(msg.sender).transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}",
            32,
            "require(msg.value == numTokens * PRICE_PER_TOKEN);"
        ]
    ],
    "overflow_simple_add.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#overflow-simple-addsol\n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity 0.8.0;\n\ncontract Overflow_Add {\n    uint public balance = 1;\n\n    function add(uint256 deposit) public {\nrequire(deposit < 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);\n        balance += deposit;\n    }\n}",
            13,
            "require(deposit < 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000);"
        ]
    ],
    "integer_overflow_minimal.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_minimal.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowMinimal {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(input < 2);\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input);\n        count -= input;\n    }\n}",
            16,
            "require(input < 2);\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input;\n        count += input;\n        count -= input);"
        ]
    ],
    "token.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Steve Marx\n * @vulnerable_at_lines: 20,22\n */\n\n pragma solidity ^0.8.0;\n\n contract Token {\n\n   mapping(address => uint) balances;\n   uint public totalSupply;\n\n   constructor(uint _initialSupply) {\n     balances[msg.sender] = totalSupply = _initialSupply;\n   }\n\n   function transfer(address _to, uint _value) public returns (bool) {\nrequire(balances[msg.sender] >= _value);\n     require(balances[msg.sender] - _value >= 0);\n\n     balances[msg.sender] -= _value;\n     balances[_to] += _value;\n     return true;\n   }\n\n   function balanceOf(address _owner) public view returns (uint balance) {\n     return balances[_owner];\n   }\n }",
            19,
            "require(balances[msg.sender] >= _value);"
        ],
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Steve Marx\n * @vulnerable_at_lines: 20,22\n */\n\n pragma solidity ^0.8.0;\n\n contract Token {\n\n   mapping(address => uint) balances;\n   uint public totalSupply;\n\n   constructor(uint _initialSupply) {\n     balances[msg.sender] = totalSupply = _initialSupply;\n   }\n\n   function transfer(address _to, uint _value) public returns (bool) {\n\n     require(balances[msg.sender] - _value >= 0);\nrequire(balances[_to] + _value >= balances[_to]);\n     balances[msg.sender] -= _value;\n     balances[_to] += _value;\n     return true;\n   }\n\n   function balanceOf(address _owner) public view returns (uint balance) {\n     return balances[_owner];\n   }\n }",
            21,
            "require(balances[_to] + _value >= balances[_to]);"
        ]
    ],
    "overflow_single_tx.sol": [
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\nrequire(count + input >= count);\n        count += input;\n    }\n\n    // ADD overflow with result stored in local variable.\n    function overflowaddtolocal(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count -);\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            17,
            "require(count + input >= count);\n        count += input;\n    }\n\n    // ADD overflow with result stored in local variable.\n    function overflowaddtolocal(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count -);"
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\nrequire(count > 0);\n        count *= input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate2(uint256 input) public {\nrequire(count > 0);\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            23,
            "require(count > 0);\n        count *= input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate2(uint256 input) public {\nrequire(count > 0);"
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\nrequire(input > count);\n        count -= input;\n    }\n\n    // ADD overflow with result stored in local variable.\n    function overflowaddtolocal(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL overflow with result stored in local variable.\n    function overflowmultolocal(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow with result stored in local variable.\n    function underflowtolocal(uint256 input) public {\nrequire(input > count);\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            29,
            "require(input > count);\n        count -= input;\n    }\n\n    // ADD overflow with result stored in local variable.\n    function overflowaddtolocal(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL overflow with result stored in local variable.\n    function overflowmultolocal(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow with result stored in local variable.\n    function underflowtolocal(uint256 input) public {\nrequire(input > count);"
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\nrequire(count + input >= count);\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            35,
            "require(count + input >= count);"
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\nrequire(count > 0);\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            41,
            "require(count > 0);"
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\nrequire(count > input);\n       \tuint res = count - input;\n    }\n\n}",
            47,
            "require(count > input);"
        ]
    ],
    "integer_overflow_add.sol": [
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite/blob/master/benchmarks/integer_overflow_add.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowAdd {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(count < 10);\n        // <yes> <report> ARITHMETIC\n        count += input;\n    }\n}\n\n//Multiple transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowAdd {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(count < 10);\n        // <yes> <report> ARITHMETIC\n        count += input;\n    }\n}\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowAdd {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(count < 10);\n        // <yes> <report> ARITHMETIC\n        count += input;\n    }\n}\n\n//Multiple transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage);\n        count += input;\n    }\n}",
            16,
            "require(count < 10);\n        // <yes> <report> ARITHMETIC\n        count += input;\n    }\n}\n\n//Multiple transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowAdd {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(count < 10);\n        // <yes> <report> ARITHMETIC\n        count += input;\n    }\n}\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowAdd {\n    uint public count = 1;\n\n    function run(uint256 input) public {\nrequire(count < 10);\n        // <yes> <report> ARITHMETIC\n        count += input;\n    }\n}\n\n//Multiple transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage);"
        ]
    ],
    "integer_overflow_multitx_onefunc_feasible.sol": [
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 22\n */\n\n//Multi-transactional, single function\n//Arithmetic instruction reachable\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowMultiTxOneFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function run(uint256 input) public {\n        if (initialized == 0) {\n            initialized = 1;\n            return;\n        }\nrequire(count >= input);\n        count -= input;\n    }\n}",
            21,
            "require(count >= input);"
        ]
    ],
    "timelock.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 22\n */\n\n//added pragma version\n pragma solidity ^0.8.0;\n \n contract TimeLock {\n\n     mapping(address => uint) public balances;\n     mapping(address => uint) public lockTime;\n\n     function deposit() public payable {\n         balances[msg.sender] += msg.value;\n         lockTime[msg.sender] = block.timestamp + 1 weeks;\n     }\n\n     function increaseLockTime(uint _secondsToIncrease) public {\nrequire(block.timestamp > lockTime[msg.sender]);\n         lockTime[msg.sender] += _secondsToIncrease;\n     }\n\n     function withdraw() public {\n         require(balances[msg.sender] > 0);\n         require(block.timestamp > lockTime[msg.sender]);\n         uint transferValue = balances[msg.sender];\n         balances[msg.sender] = 0;\n         payable(msg.sender).transfer(transferValue);\n     }\n }",
            21,
            "require(block.timestamp > lockTime[msg.sender]);"
        ]
    ],
    "insecure_transfer.sol": [
        [
            "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#front-running-aka-transaction-ordering-dependence\n * @author: consensys\n * @vulnerable_at_lines: 18\n */\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowAdd {\n    mapping (address => uint256) public balanceOf;\n\n    // INSECURE\n    function transfer(address _to, uint256 _value) public{\n        /* Check if sender has balance */\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\nrequire(balanceOf[_to] + _value >= balanceOf[_to]);\n        balanceOf[_to] += _value;\n}\n\n}",
            17,
            "require(balanceOf[_to] + _value >= balanceOf[_to]);"
        ]
    ],
    "integer_overflow_multitx_multifunc_feasible.sol": [
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 25\n */\n\n//Multi-transactional, multi-function\n//Arithmetic instruction reachable\n\npragma solidity ^0.8.0;\n\ncontract IntegerOverflowMultiTxMultiFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function init() public {\n        initialized = 1;\n    }\n\n    function run(uint256 input) public {\n        if (initialized == 0) {\n            return;\n        }\nrequire(count >= input);\n        count -= input;\n    }\n}",
            24,
            "require(count >= input);"
        ]
    ]
}